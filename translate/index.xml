<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Translates on WeiZhang555</title>
    <link>https://weizhang555.github.io/translate/</link>
    <description>Recent content in Translates on WeiZhang555</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright> © Zhang Wei(weizhang555)</copyright>
    <lastBuildDate>Wed, 26 Jul 2023 19:10:46 +0800</lastBuildDate><atom:link href="https://weizhang555.github.io/translate/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>防火不如救火，治未病不如治已病，好代码不如好吆喝</title>
      <link>https://weizhang555.github.io/translate/whats-good-engineer/</link>
      <pubDate>Wed, 26 Jul 2023 19:10:46 +0800</pubDate>
      
      <guid>https://weizhang555.github.io/translate/whats-good-engineer/</guid>
      <description>
        
          
            1. 古代版 暖曰：“王独不闻魏文王之问扁鹊耶？
曰：‘子昆弟三人其孰最善为医？’
扁鹊曰：‘长兄最善，中兄次之，扁鹊最为下。’
魏文侯曰：‘可得闻邪？’
扁鹊曰：‘长兄于病视神，未有形而除之，故名不出于家。中兄治病，其在毫毛，故名不出于闾。
若扁鹊者，镵血脉，投毒药，副肌肤，闲而名出闻于诸侯。’
-- 《鹖冠子·世贤第十六》
2. 现代版 王问：“你们兄弟三人谁的代码写的最好？”
小明答：“大哥写的最好，二哥其次，我写的最差”。
王问：“可是为什么你的绩效最好呢？”
小明答：“大哥写代码都是一蹴而就，写的又快又好，跑十年都不出一个故障，写完了就喝茶聊天，因而领导觉得他工作量不饱和不给好绩效，所以只有我们圈子里的人知道他厉害；
二哥写代码也写的很好，虽然bug多，但测试同学提出bug很快就修好，不会遗留到线上，因而绩效马马虎虎；
我写的最差，上线了还时不时出故障，但是我天天熬夜写代码，加班修复线上问题，懂得拉会议，能摇人。客户说我活儿好态度好，领导说我善于协调同时团队协作能力强，因而我绩效最好”
3. 评 防火不如救火，治未病不如治已病，好代码不如好吆喝。
不知道从何评起，只有一点感悟和一声叹息，与君共勉。
          
          
        
      </description>
    </item>
    
    <item>
      <title>使用BPF ring buffer</title>
      <link>https://weizhang555.github.io/translate/using-bpf-ringbuffer/</link>
      <pubDate>Mon, 24 Jul 2023 23:36:46 +0800</pubDate>
      
      <guid>https://weizhang555.github.io/translate/using-bpf-ringbuffer/</guid>
      <description>
        
          
            本文介绍如何使用BPF ring buffer，原文来自这里。
在学习ring buffer的使用时，我翻阅了很多文档，筛选过后发现这篇文章是很不错的学习材料，即便它最后一次更新停留在2021年3月，内容也依旧可靠。
以下为正文。
Update March 30th, 2021: This article is still relevant if you are looking for a practical example on how to use the BPF Ring Buffer. If you want a deep explaination on how it works I suggest to visit the blog of the main author of this feature Andrii here. Enjoy the learning! :)
2021 年 3 月 30 日更新：如果您正在寻找有关如何使用 BPF 环形缓冲区的实际示例，本文仍然具有相关性。 如果您想深入了解其工作原理，我建议访问此功能主要作者 Andrii 的博客。 享受学习的乐趣吧！ :)
          
          
        
      </description>
    </item>
    
    <item>
      <title>BPF的设计原则Q&amp;A</title>
      <link>https://weizhang555.github.io/translate/bpf-design-qa/</link>
      <pubDate>Fri, 21 Jul 2023 00:10:46 +0800</pubDate>
      
      <guid>https://weizhang555.github.io/translate/bpf-design-qa/</guid>
      <description>
        
          
            原文链接：BPF Design Q&amp;amp;A
声明：
本文根据截止2023-07-22日的文档最新内容进行翻译，无法保证永远是最新的。 由于作者水平有限，难免出现错误和遗漏，如果发现有错误的内容欢迎在下方评论区留言指正。 这篇文章是以文档的形式介绍了ebpf的设计上的考虑，对于提升ebpf的理解很有好处，这是为什么单独挑选这篇文章进行翻译的原因。
以下是正文。
问：BPF是一种类似x86和arm64的通用指令集吗？ 答: NO.
问：BPF是通用的虚拟机吗？ 答：NO。
BPF是遵循C语言调用约定(C calling convention)的一种通用指令集。
问：为什么选择了C语言调用约定？ 答：因为BPF程序是为在Linux kernel内运行而设计的，kernel是用C语言写的，因而BPF定义了与x86和arm64两个最常用的架构兼容的指令集(同时也考虑到了其他架构的一些重要“怪癖”)，也定义了与那些架构上的linux kernel的C调用约定兼容的调用约定。
问：未来会支持多个返回值吗？ 答：NO。BPF仅支持使用R0寄存器作为函数返回值。
问：未来会支持超过5个函数参数吗？ 答：NO。BPF 调用约定仅允许寄存器 R1-R5 用作参数。 BPF 不是一个独立的指令集。 （与允许 msft、cdecl 和其他约定的 x64 ISA 不同）
问：BPF程序可以访问指令指针(instruction pointer)或返回地址吗？ 答：NO
问：BPF程序可以访问栈指针(stack pointer)吗？ 答：NO。
只有帧指针(frame pointer)(寄存器R10)可以被访问。从编译器角度看，拥有栈指针是有必要的。例如，LLVM定义了寄存器R11作为BPF后端的栈指针，但是它确保了生成的代码永远不会使用它。
问：C 调用约定是否会减少可能的用例？ 答：YES。
BPF的设计强制以内核helper函数和内核对象（像BPF maps）的形式添加主要功能，并且他们之间可以无缝互操作。它允许kernel调用BPF程序，并且BPF程序可以零开销调用kernel helpers，因为他们都是原生C代码。对于与本机内核 C 代码无法区分的 JIT 化 BPF 程序尤其如此。
问：这是否意味着对BPF代码进行‘创新’扩展是不允许的？ 答：算对吧（Soft yes）。
至少到目前为止成立，直到BPF代码支持了bpf-to-bpf calls, indirect calls, loops, global variables, jump tables, read-only sections, 和其他所有C代码可以产生的结构。
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
