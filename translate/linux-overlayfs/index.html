
<!DOCTYPE html>
<html
  lang="en"
  data-figures=""
  
    class="page"
  
  
  >
  <head>
<title>[内核文档翻译] Overlay文件系统 | WeiZhang555</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">





<meta property="og:locale" content="en" />

<meta property="og:type" content="article">
<meta name="description" content="本文原文来自内核源码文档，源码链接。
官方网站：https://docs.kernel.org
Overlay文件系统（Overlay Filesystem） This document describes a prototype for a new approach to providing …" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:creator" content="">
<meta name="twitter:title" content="[内核文档翻译] Overlay文件系统" />
<meta name="twitter:image" content="https://weizhang555.github.io/images/thumbnail.png"/>
<meta property="og:url" content="https://weizhang555.github.io/translate/linux-overlayfs/" />
<meta property="og:title" content="[内核文档翻译] Overlay文件系统" />
<meta property="og:description" content="本文原文来自内核源码文档，源码链接。
官方网站：https://docs.kernel.org
Overlay文件系统（Overlay Filesystem） This document describes a prototype for a new approach to providing …" />
<meta property="og:image" content="https://weizhang555.github.io/images/thumbnail.png" />

<link rel="apple-touch-icon" sizes="180x180" href="https://weizhang555.github.io/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://weizhang555.github.io/icons/favicon-32x32.png">
<link rel="manifest" href="https://weizhang555.github.io/icons/site.webmanifest">

<link rel="canonical" href="https://weizhang555.github.io/translate/linux-overlayfs/">



<link rel="preload" href="https://weizhang555.github.io/css/styles.42e2c5f6d8cf9c52872666f8d8b2678ad0c426978b9d78aff3c33b7a1e7f6f97f54bcdaf0518a25fb0fe26367d04f8b07c683b3b38b331cb098daadee06b1f3e.css" integrity = "sha512-QuLF9tjPnFKHJmb42LJnitDEJpeLnXiv88M7eh5/b5f1S82vBRiiX7D&#43;JjZ9BPiwfGg7OzizMcsJjare4GsfPg==" as="style" crossorigin="anonymous">



<link rel="preload" href="https://weizhang555.github.io/en/js/bundle.bbf6eab9d0e31d2d45a0d302b93cfbdd7c169deb9518a671024c06b869cc688d310d3e3d6f813aade70aa8dfb8f5b467207588efc0b8a721cbeeb3e059b229da.js" as="script" integrity=
"sha512-u/bqudDjHS1FoNMCuTz73XwWneuVGKZxAkwGuGnMaI0xDT49b4E6recKqN&#43;49bRnIHWI78C4pyHL7rPgWbIp2g==" crossorigin="anonymous">


<link rel="stylesheet" type="text/css" href="https://weizhang555.github.io/css/styles.42e2c5f6d8cf9c52872666f8d8b2678ad0c426978b9d78aff3c33b7a1e7f6f97f54bcdaf0518a25fb0fe26367d04f8b07c683b3b38b331cb098daadee06b1f3e.css" integrity="sha512-QuLF9tjPnFKHJmb42LJnitDEJpeLnXiv88M7eh5/b5f1S82vBRiiX7D&#43;JjZ9BPiwfGg7OzizMcsJjare4GsfPg==" crossorigin="anonymous">

  </head>
  <body
    data-code="10"
    data-lines="false"
    id="documentTop"
    data-lang="en"
  >

<header class="nav_header" >
  <nav class="nav"><a href='https://weizhang555.github.io/' class="nav_brand nav_item" title="WeiZhang555">WeiZhang555
  <div class="nav_close">
    <div><svg class="icon">
  <title>open-menu</title>
  <use xlink:href="#open-menu"></use>
</svg>
<svg class="icon">
  <title>closeme</title>
  <use xlink:href="#closeme"></use>
</svg>
</div>
  </div>
</a>

    <div class='nav_body nav_body_left'>
      
      
      
        

  <div class="nav_parent">
    <a href="https://weizhang555.github.io/original" class="nav_item" title="原创">原创 </a>
  </div>
  <div class="nav_parent">
    <a href="https://weizhang555.github.io/translate" class="nav_item" title="译文">译文 </a>
  </div>
  <div class="nav_parent">
    <a href="https://weizhang555.github.io/republish" class="nav_item" title="转载">转载 </a>
  </div>
  <div class="nav_parent">
    <a href="https://weizhang555.github.io/about/" class="nav_item" title="关于">关于 </a>
  </div>
      
<div class='follow'>
  <a href="https://github.com/weizhang555">
    <svg class="icon">
  <title>github</title>
  <use xlink:href="#github"></use>
</svg>

  </a>
<div class="color_mode">
  <input type="checkbox" class="color_choice" id="mode">
</div>

</div>

    </div>
  </nav>
</header>

    <main>
  
<div class="grid-inverse wrap content">
  <article class="post_content">
    <h1 class="post_title">[内核文档翻译] Overlay文件系统</h1>
  <div class="post_meta">
    <span><svg class="icon">
  <title>calendar</title>
  <use xlink:href="#calendar"></use>
</svg>
</span>
    <span class="post_date">
      Aug 16, 2023</span>
    <span class="post_time"> · 24 min read</span><span>&nbsp;· <a href='https://weizhang555.github.io/tags/%E5%86%85%E6%A0%B8/' title="内核" class="post_tag button button_translucent">内核
        </a>
    </span>
    <span class="page_only">&nbsp;·
  <div class="post_share">
    Share on:
    <a href="https://twitter.com/intent/tweet?text=%5b%e5%86%85%e6%a0%b8%e6%96%87%e6%a1%a3%e7%bf%bb%e8%af%91%5d%20Overlay%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f&url=https%3a%2f%2fweizhang555.github.io%2ftranslate%2flinux-overlayfs%2f&tw_p=tweetbutton" class="twitter" title="Share on Twitter" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>twitter</title>
  <use xlink:href="#twitter"></use>
</svg>

    </a>
    <a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fweizhang555.github.io%2ftranslate%2flinux-overlayfs%2f&t=%5b%e5%86%85%e6%a0%b8%e6%96%87%e6%a1%a3%e7%bf%bb%e8%af%91%5d%20Overlay%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" class="facebook" title="Share on Facebook" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>facebook</title>
  <use xlink:href="#facebook"></use>
</svg>

    </a>
    <a href="#linkedinshare" id = "linkedinshare" class="linkedin" title="Share on LinkedIn" rel="nofollow">
      <svg class="icon">
  <title>linkedin</title>
  <use xlink:href="#linkedin"></use>
</svg>

    </a>
    <a href="https://weizhang555.github.io/translate/linux-overlayfs/" title="Copy Link" class="link link_yank">
      <svg class="icon">
  <title>copy</title>
  <use xlink:href="#copy"></use>
</svg>

    </a>
  </div>
  </span>
  </div>

      <div class="post_toc">
        <h2>Overview</h2>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#overlay对象-overlay-objects">Overlay对象 （Overlay objects）</a></li>
    <li><a href="#inode属性inode-properties">Inode属性（Inode properties）</a></li>
    <li><a href="#上层和下层upper-and-lower">上层和下层（Upper and Lower）</a></li>
    <li><a href="#目录directories">目录（Directories）</a></li>
    <li><a href="#whiteout和不透明目录whiteouts-and-opaque-directories">whiteout和不透明目录（whiteouts and opaque directories）</a></li>
    <li><a href="#readdirreaddir">readdir（readdir）</a></li>
    <li><a href="#重命名目录renaming-directories">重命名目录（renaming directories）</a></li>
    <li><a href="#非目录non-directories">非目录（Non-directories）</a></li>
    <li><a href="#权限模型permission-model">权限模型（Permission model）</a></li>
    <li><a href="#多个下层multiple-lower-layers">多个下层（Multiple lower layers）</a></li>
    <li><a href="#仅向上拷贝元数据-metadata-only-copy-up">仅向上拷贝元数据 (Metadata only copy up)</a></li>
    <li><a href="#只含数据的下层data-only-lower-layers">只含数据的下层（Data-only lower layers）</a></li>
    <li><a href="#共享和复制层sharing-and-copying-layers">共享和复制层（Sharing and copying layers）</a></li>
    <li><a href="#非标准行为non-standard-behavior">非标准行为（Non-standard behavior）</a></li>
    <li><a href="#修改底层文件系统changes-to-underlying-filesystems">修改底层文件系统（Changes to underlying filesystems）</a></li>
    <li><a href="#nfs导出nfs-export">NFS导出（NFS export）</a></li>
    <li><a href="#易失性挂载volatile-mount">易失性挂载（Volatile mount）</a></li>
    <li><a href="#用户扩展属性user-xattr">用户扩展属性（User xattr）</a></li>
    <li><a href="#测试套testsuite">测试套（Testsuite）</a></li>
  </ul>
</nav>
      </div>
    
    <div class="post_body"><p>本文原文来自内核源码文档，<a href="https://docs.kernel.org/filesystems/overlayfs.html">源码链接</a>。</p>
<p>官方网站：https://docs.kernel.org</p>
<h1 id="overlay文件系统overlay-filesystem">Overlay文件系统（Overlay Filesystem）</h1>
<blockquote>
<p>This document describes a prototype for a new approach to providing overlay-filesystem functionality in Linux (sometimes referred to as union-filesystems). An overlay-filesystem tries to present a filesystem which is the result over overlaying one filesystem on top of the other.</p>
</blockquote>
<p>本文档描述了在 Linux 中提供Overlay(覆盖)文件系统功能（有时称为联合文件系统）的新方法的原型。 Overlay文件系统尝试呈现一种文件系统，该文件系统是将一个文件系统覆盖在另一个文件系统之上的结果。</p>
<h2 id="overlay对象-overlay-objects">Overlay对象 （Overlay objects）</h2>
<blockquote>
<p>The overlay filesystem approach is 'hybrid', because the objects that appear in the filesystem do not always appear to belong to that filesystem. In many cases, an object accessed in the union will be indistinguishable from accessing the corresponding object from the original filesystem. This is most obvious from the 'st_dev' field returned by stat(2).</p>
<p>While directories will report an st_dev from the overlay-filesystem, non-directory objects may report an st_dev from the lower filesystem or upper filesystem that is providing the object. Similarly st_ino will only be unique when combined with st_dev, and both of these can change over the lifetime of a non-directory object. Many applications and tools ignore these values and will not be affected.</p>
</blockquote>
<p>Overlay文件系统方法是“混合”的，因为文件系统中出现的对象看起来并不总是属于该文件系统。 在许多情况下，在联合中访问的对象与从原始文件系统访问相应的对象没有什么区别。 这在 stat(2) 返回的“st_dev”字段中最为明显。</p>
<p>虽然目录将报告来自覆盖文件系统的 st_dev，但非目录对象可能会报告来自提供该对象的下层文件系统或上层文件系统的 st_dev。 类似地，st_ino 仅在与 st_dev 组合时才是唯一的，并且这两者都可以在非目录对象的生命周期中发生变化。 许多应用程序和工具会忽略这些值并且不会受到影响。</p>
<blockquote>
<p>In the special case of all overlay layers on the same underlying filesystem, all objects will report an st_dev from the overlay filesystem and st_ino from the underlying filesystem. This will make the overlay mount more compliant with filesystem scanners and overlay objects will be distinguishable from the corresponding objects in the original filesystem.</p>
<p>On 64bit systems, even if all overlay layers are not on the same underlying filesystem, the same compliant behavior could be achieved with the &quot;xino&quot; feature. The &quot;xino&quot; feature composes a unique object identifier from the real object st_ino and an underlying fsid index. The &quot;xino&quot; feature uses the high inode number bits for fsid, because the underlying filesystems rarely use the high inode number bits. In case the underlying inode number does overflow into the high xino bits, overlay filesystem will fall back to the non xino behavior for that inode.</p>
<p>The &quot;xino&quot; feature can be enabled with the &quot;-o xino=on&quot; overlay mount option. If all underlying filesystems support NFS file handles, the value of st_ino for overlay filesystem objects is not only unique, but also persistent over the lifetime of the filesystem. The &quot;-o xino=auto&quot; overlay mount option enables the &quot;xino&quot; feature only if the persistent st_ino requirement is met.</p>
</blockquote>
<p>在所有覆盖层都位于同一底层文件系统上的特殊情况下，所有对象都将报告来自覆盖文件系统的 st_dev 和来自底层文件系统的 st_ino 。 这将使覆盖挂载更符合文件系统扫描器的要求，并且覆盖对象将与原始文件系统中的相应对象区分开来。</p>
<p>在 64 位系统上，即使所有覆盖层不在同一底层文件系统上，也可以通过“xino”功能实现相同的合规行为。 “xino”功能由真实对象 st_ino 的唯一对象标识符和底层 fsid 索引组成。 “xino”功能使用 fsid 的高 inode 编号位，因为底层文件系统很少使用高 inode 编号位。 如果底层 inode 编号确实溢出到高 xino 位，覆盖文件系统将回退到该 inode 的非 xino 行为。</p>
<p>可以使用“-o xino=on”overlay挂载选项启用“xino”特性。 如果所有底层文件系统都支持 NFS 文件句柄，则Overlay文件系统对象的 st_ino 值不仅是唯一的，而且在文件系统的生命周期内是持久的。 仅当满足持久 st_ino 要求时，“-o xino=auto” overlay挂载选项才会启用“xino”功能。</p>
<blockquote>
<p>The following table summarizes what can be expected in different overlay configurations.</p>
</blockquote>
<p>下表总结了不同overlay配置下的预期结果。</p>
<h2 id="inode属性inode-properties">Inode属性（Inode properties）</h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 7%" />
<col style="width: 9%" />
<col style="width: 7%" />
<col style="width: 9%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr class="row-odd">
<th ><p>配置</p></th>
<th colspan="2"><p>持久化st_ino</p></th>
<th colspan="2"><p>统一的st_dev</p></th>
<th colspan="2"><p>st_ino == d_ino</p></th>
<th colspan="2"><p>d_ino == i_ino [*]</p></th>
</tr>
</thead>
<tbody>
<tr >
<td rowspan="2"></td>
<td rowspan="2"><p>dir</p></td>
<td rowspan="2"><p>!dir</p></td>
<td rowspan="2"><p>dir</p></td>
<td rowspan="2"><p>!dir</p></td>
<td rowspan="2"><p>dir</p></td>
<td rowspan="2"><p>!dir</p></td>
<td rowspan="2"><p>dir</p></td>
<td rowspan="2"><p>!dir</p></td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td><p>所有的层在同一个文件系统上</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>所有层在同一文件系统上, xino=off</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>xino=on/auto</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>xino=on/auto,
ino 溢出</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
</tr>
</tbody>
</table>
<blockquote>
<p>[*] nfsd v3 readdirplus verifies d_ino == i_ino. i_ino is exposed via several /proc files, such as /proc/locks and /proc/self/fdinfo/&lt;fd&gt; of an inotify file descriptor.</p>
</blockquote>
<p>注：nfsd v3 readdirplus 验证 d_ino == i_ino。 i_ino 通过多个 /proc 文件暴露，例如 inotify 文件描述符的 /proc/locks 和 /proc/self/fdinfo/&lt;fd&gt; 。</p>
<h2 id="上层和下层upper-and-lower">上层和下层（Upper and Lower）</h2>
<blockquote>
<p>An overlay filesystem combines two filesystems - an 'upper' filesystem and a 'lower' filesystem. When a name exists in both filesystems, the object in the 'upper' filesystem is visible while the object in the 'lower' filesystem is either hidden or, in the case of directories, merged with the 'upper' object.</p>
<p>It would be more correct to refer to an upper and lower 'directory tree' rather than 'filesystem' as it is quite possible for both directory trees to be in the same filesystem and there is no requirement that the root of a filesystem be given for either upper or lower.</p>
</blockquote>
<p>Overlay文件系统结合了两个文件系统——“上层”文件系统和“下层”文件系统。 当两个文件系统中都存在某个名字时，“上层”文件系统中的对象可见，而“下层”文件系统中的对象被隐藏，对目录来说则会与“上层”对象合并。</p>
<p>更准确的说法，上层和下层是“目录树”而不是“文件系统”，因为两个目录树很可能位于同一文件系统中，并且并不需要将文件系统的根目录给到上层或下层。</p>
<p>（译者注：上层和下层可以指定某个文件系统的某个目录，不需要一定要将文件系统的/目录给到某一层）</p>
<blockquote>
<p>A wide range of filesystems supported by Linux can be the lower filesystem, but not all filesystems that are mountable by Linux have the features needed for OverlayFS to work. The lower filesystem does not need to be writable. The lower filesystem can even be another overlayfs. The upper filesystem will normally be writable and if it is it must support the creation of trusted.* and/or user.* extended attributes, and must provide valid d_type in readdir responses, so NFS is not suitable.</p>
<p>A read-only overlay of two read-only filesystems may use any filesystem type.</p>
</blockquote>
<p>Linux 支持的多种文件系统都可以是下层文件系统，但并非所有 Linux 可挂载的文件系统都具有 OverlayFS 工作所需的特性。 下层文件系统不需要是可写的。 下层文件系统甚至可以是另一个overlayfs。 上层文件系统通常是可写的，如果是的话，它必须支持创建 trust.* 和/或 user.* 扩展属性，并且必须在 readdir 响应中提供有效的 d_type，因此 NFS 不符合。</p>
<p>两个只读文件系统组成的只读overlay fs可以使用任何文件系统类型。</p>
<h2 id="目录directories">目录（Directories）</h2>
<blockquote>
<p>Overlaying mainly involves directories. If a given name appears in both upper and lower filesystems and refers to a non-directory in either, then the lower object is hidden - the name refers only to the upper object.</p>
<p>Where both upper and lower objects are directories, a merged directory is formed.</p>
<p>At mount time, the two directories given as mount options &quot;lowerdir&quot; and &quot;upperdir&quot; are combined into a merged directory:</p>
</blockquote>
<p>覆盖主要涉及目录。 如果给定名称同时出现在上层和下层文件系统中，并且指向任一文件系统中的非目录项，则下层对象将被隐藏 - 该名称仅引用上层对象。</p>
<p>当上层和下层对象都是目录时，就形成一个合并目录。</p>
<p>在挂载时，通过挂载选项“lowerdir”和“upperdir”指定的两个目录将组合成一个合并目录：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">mount -t overlay overlay -olowerdir=/lower,upperdir=/upper,workdir=/work /merged
</span></span></code></pre></div><blockquote>
<p>The &quot;workdir&quot; needs to be an empty directory on the same filesystem as upperdir.</p>
<p>Then whenever a lookup is requested in such a merged directory, the lookup is performed in each actual directory and the combined result is cached in the dentry belonging to the overlay filesystem. If both actual lookups find directories, both are stored and a merged directory is created, otherwise only one is stored: the upper if it exists, else the lower.</p>
<p>Only the lists of names from directories are merged. Other content such as metadata and extended attributes are reported for the upper directory only. These attributes of the lower directory are hidden.</p>
</blockquote>
<p>“workdir”必须是与 upperdir 位于同一文件系统上的空目录。</p>
<p>然后，每当在这样的合并目录中执行查找动作时，都会在每个实际目录中执行查找，并将组合结果缓存在属于overlay文件系统的 dentry 中。 如果两层都找到目录，则两个目录都会被存储并创建一个合并目录，否则仅存储一个目录：如果上层存在则为上层目录，否则为下层目录。</p>
<p>仅合并目录中的名称列表。 其他内容（例如元数据和扩展属性）仅报告上层目录的。 下层目录的这些属性是隐藏的。</p>
<h2 id="whiteout和不透明目录whiteouts-and-opaque-directories">whiteout和不透明目录（whiteouts and opaque directories）</h2>
<p>（译者注：whiteout没有找到广受认可的翻译，单独翻译单词有”白化“，”临时性失明“，&quot;涂改液&quot;的意思，我认为”涂改“是个不错的翻译。为保持准确，以下直接使用whiteout而不做翻译）</p>
<blockquote>
<p>In order to support rm and rmdir without changing the lower filesystem, an overlay filesystem needs to record in the upper filesystem that files have been removed. This is done using whiteouts and opaque directories (non-directories are always opaque).</p>
</blockquote>
<p>为了在不更改下层文件系统的情况下支持 rm 和 rmdir，overlay文件系统需要在上层文件系统中记录文件已被删除。 这是通过使用whiteouts和不透明目录来完成的（非目录总是不透明的）。</p>
<blockquote>
<p>A whiteout is created as a character device with 0/0 device number. When a whiteout is found in the upper level of a merged directory, any matching name in the lower level is ignored, and the whiteout itself is also hidden.</p>
</blockquote>
<p>whiteout以具有 0/0 设备号的字符设备的形态创建。 当在合并目录的上层发现whiteout时，下层中任何匹配的名称都会被忽略，并且whiteout本身也会被隐藏。</p>
<blockquote>
<p>A directory is made opaque by setting the xattr &quot;trusted.overlay.opaque&quot; to &quot;y&quot;. Where the upper filesystem contains an opaque directory, any directory in the lower filesystem with the same name is ignored.</p>
</blockquote>
<p>通过将扩展属性（xattr）“trusted.overlay.opaque”设置为“y”，目录可以变得不透明。 如果上层文件系统包含一个不透明目录，则下层文件系统中的任何同名目录都会被忽略。</p>
<h2 id="readdirreaddir">readdir（readdir）</h2>
<blockquote>
<p>When a 'readdir' request is made on a merged directory, the upper and lower directories are each read and the name lists merged in the obvious way (upper is read first, then lower - entries that already exist are not re-added). This merged name list is cached in the 'struct file' and so remains as long as the file is kept open. If the directory is opened and read by two processes at the same time, they will each have separate caches. A seekdir to the start of the directory (offset 0) followed by a readdir will cause the cache to be discarded and rebuilt.</p>
</blockquote>
<p>当对合并目录发出“readdir”请求时，将分别读取上层目录和下层目录，并以明显的方式合并名称列表（首先读取上层目录，然后读取下层目录 -- 不会重新添加已存在的条目）。 此合并的名称列表缓存在'struct file'结构体中，因此只要文件保持打开状态，该列表就会保留下来。 如果目录同时被两个进程打开和读取，它们将各自拥有单独的缓存。 对目录开头（偏移量 0）执行 seekdir，然后再次readdir 将导致缓存被丢弃并重建。</p>
<blockquote>
<p>This means that changes to the merged directory do not appear while a directory is being read. This is unlikely to be noticed by many programs.</p>
</blockquote>
<p>这意味着目录正在被读取时对合并目录进行的更改不会显示出来。 许多程序不太可能注意到这一点。</p>
<blockquote>
<p>seek offsets are assigned sequentially when the directories are read. Thus if</p>
<ul>
<li>read part of a directory</li>
<li>remember an offset, and close the directory</li>
<li>re-open the directory some time later</li>
<li>seek to the remembered offset</li>
</ul>
<p>there may be little correlation between the old and new locations in the list of filenames, particularly if anything has changed in the directory.</p>
<p>Readdir on directories that are not merged is simply handled by the underlying directory (upper or lower).</p>
</blockquote>
<p>读取目录时，将按顺序分配查找偏移量。 因此如果</p>
<ul>
<li>读取目录的一部分</li>
<li>记住偏移量，然后关闭目录</li>
<li>稍后重新打开目录</li>
<li>寻找记住的偏移量</li>
</ul>
<p>文件名列表中的旧位置和新位置之间可能几乎没有相关性，特别是当目录中发生任何更改时。</p>
<p>未合并目录上的 Readdir 仅由底层目录（上层或下层）处理。</p>
<h2 id="重命名目录renaming-directories">重命名目录（renaming directories）</h2>
<blockquote>
<p>When renaming a directory that is on the lower layer or merged (i.e. the directory was not created on the upper layer to start with) overlayfs can handle it in two different ways:</p>
<ol>
<li>
<p>return EXDEV error: this error is returned by rename(2) when trying to move a file or directory across filesystem boundaries. Hence applications are usually prepared to hande this error (mv(1) for example recursively copies the directory tree). This is the default behavior.</p>
</li>
<li>
<p>If the &quot;redirect_dir&quot; feature is enabled, then the directory will be copied up (but not the contents). Then the &quot;trusted.overlay.redirect&quot; extended attribute is set to the path of the original location from the root of the overlay. Finally the directory is moved to the new location.</p>
</li>
</ol>
<p>There are several ways to tune the &quot;redirect_dir&quot; feature.</p>
</blockquote>
<p>当重命名位于下层或合并的目录时（即该目录不是在上层开始创建的），overlayfs 可以通过两种不同的方式处理它：</p>
<ol>
<li>
<p>返回 EXDEV 错误：当尝试跨文件系统边界移动文件或目录时，rename(2) 返回此错误。 因此，应用程序通常都会做好准备处理此错误（例如 mv(1) 递归复制目录树）。 这是默认行为。</p>
</li>
<li>
<p>如果启用了“redirect_dir”功能，则将向上复制目录（但不复制内容）。 然后，“trusted.overlay.redirect”扩展属性被设置为从overlay的根开始的原始位置的路径。 最后该目录被移动到新位置。</p>
</li>
</ol>
<p>有多种方法可以调整“redirect_dir”功能。</p>
<blockquote>
<p>Kernel config options:</p>
<ul>
<li>
<p>OVERLAY_FS_REDIRECT_DIR:
If this is enabled, then redirect_dir is turned on by default.</p>
</li>
<li>
<p>OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW:
If this is enabled, then redirects are always followed by default. Enabling this results in a less secure configuration. Enable this option only when worried about backward compatibility with kernels that have the redirect_dir feature and follow redirects even if turned off.</p>
</li>
</ul>
</blockquote>
<p>内核配置选项：</p>
<ul>
<li>OVERLAY_FS_REDIRECT_DIR：</li>
</ul>
<p>如果启用此选项，则默认情况下将打开redirect_dir。</p>
<ul>
<li>OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW：</li>
</ul>
<p>如果启用此功能，则默认情况下始终跟随重定向。 启用此功能会导致配置安全性降低。 仅当你关心与具有redirect_dir 功能的内核的向后兼容问题时才启用此选项，并且即使目录重定向被关闭也依然跟随重定向。</p>
<p>（译者注：”跟随重定向“应该指的是寻着”重定向扩展属性“去找到原目录或文件）</p>
<blockquote>
<p>Module options (can also be changed through /sys/module/overlay/parameters/):</p>
<ul>
<li>
<p>&quot;redirect_dir=BOOL&quot;:
See OVERLAY_FS_REDIRECT_DIR kernel config option above.</p>
</li>
<li>
<p>&quot;redirect_always_follow=BOOL&quot;:
See OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW kernel config option above.</p>
</li>
<li>
<p>&quot;redirect_max=NUM&quot;:
The maximum number of bytes in an absolute redirect (default is 256).</p>
</li>
</ul>
</blockquote>
<p>模块选项（也可以通过/sys/module/overlay/parameters/更改）：</p>
<ul>
<li>
<p>“redirect_dir=BOOL”：
请参阅上面的 OVERLAY_FS_REDIRECT_DIR 内核配置选项。</p>
</li>
<li>
<p>“redirect_always_follow=BOOL”：
请参阅上面的 OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW 内核配置选项。</p>
</li>
<li>
<p>“redirect_max=NUM”：
绝对重定向中的最大字节数（默认为 256）。</p>
</li>
</ul>
<blockquote>
<p>Mount options:</p>
<ul>
<li>
<p>&quot;redirect_dir=on&quot;:
Redirects are enabled.</p>
</li>
<li>
<p>&quot;redirect_dir=follow&quot;:
Redirects are not created, but followed.</p>
</li>
<li>
<p>&quot;redirect_dir=nofollow&quot;:
Redirects are not created and not followed.</p>
</li>
<li>
<p>&quot;redirect_dir=off&quot;:
If &quot;redirect_always_follow&quot; is enabled in the kernel/module config, this &quot;off&quot; traslates to &quot;follow&quot;, otherwise it translates to &quot;nofollow&quot;.</p>
</li>
</ul>
</blockquote>
<p>挂载选项：</p>
<ul>
<li>
<p>“redirect_dir=on”：
重定向已启用。</p>
</li>
<li>
<p>“redirect_dir=follow”：
重定向不会创建，但是会跟随。</p>
</li>
<li>
<p>“redirect_dir=nofollow”：
重定向不会创建也不跟随。</p>
</li>
<li>
<p>“redirect_dir=off”：
如果在内核/模块配置中启用了“redirect_always_follow”，则此“off”将转换为“follow”，否则它将转换为“nofollow”。</p>
</li>
</ul>
<blockquote>
<p>When the NFS export feature is enabled, every copied up directory is indexed by the file handle of the lower inode and a file handle of the upper directory is stored in a &quot;trusted.overlay.upper&quot; extended attribute on the index entry. On lookup of a merged directory, if the upper directory does not match the file handle stores in the index, that is an indication that multiple upper directories may be redirected to the same lower directory. In that case, lookup returns an error and warns about a possible inconsistency.</p>
<p>Because lower layer redirects cannot be verified with the index, enabling NFS export support on an overlay filesystem with no upper layer requires turning off redirect follow (e.g. &quot;redirect_dir=nofollow&quot;).</p>
</blockquote>
<p>当启用 NFS 导出功能时，每个向上拷贝的目录都会通过下层 inode 的文件句柄进行索引，上层目录的文件句柄存储在索引条目上的“trusted.overlay.upper”扩展属性中。 在查找合并目录时，如果上层目录与索引中的文件句柄存储不匹配，则表明多个上层目录可能被重定向到同一个下层目录。 在这种情况下，查找操作会返回错误并警告可能存在的不一致。</p>
<p>由于无法使用索引验证下层重定向，因此在没有上层的覆盖文件系统上启用 NFS 导出支持需要关闭重定向跟随（例如“redirect_dir=nofollow”）。</p>
<h2 id="非目录non-directories">非目录（Non-directories）</h2>
<blockquote>
<p>Objects that are not directories (files, symlinks, device-special files etc.) are presented either from the upper or lower filesystem as appropriate. When a file in the lower filesystem is accessed in a way the requires write-access, such as opening for write access, changing some metadata etc., the file is first copied from the lower filesystem to the upper filesystem (copy_up). Note that creating a hard-link also requires copy_up, though of course creation of a symlink does not.</p>
</blockquote>
<p>非目录的对象（文件、符号链接、设备专用文件等）根据需要从上层或下层文件系统中呈现。 当需要以写访问的方式访问下层文件系统中的文件时，例如写访问的方式打开、更改某些元数据等，该文件首先从下层文件系统复制到上层文件系统（向上拷贝，copy_up）。 请注意，创建硬链接也需要 copy_up，但创建符号链接并不需要。</p>
<blockquote>
<p>The copy_up may turn out to be unnecessary, for example if the file is opened for read-write but the data is not modified.</p>
</blockquote>
<p>copy_up 可能是不必要的，例如，如果文件以读写方式打开，但数据并未修改。</p>
<blockquote>
<p>The copy_up process first makes sure that the containing directory exists in the upper filesystem - creating it and any parents as necessary. It then creates the object with the same metadata (owner, mode, mtime, symlink-target etc.) and then if the object is a file, the data is copied from the lower to the upper filesystem. Finally any extended attributes are copied up.</p>
</blockquote>
<p>copy_up 进程首先确保文件所在目录存在于上层文件系统中 - 创建它以及根据需要创建任何父目录。 然后，它使用相同的元数据（所有者、模式、修改时间、符号链接目标等）创建对象，然后如果该对象是文件，则将数据从下层文件系统复制到上层文件系统。 最后，所有扩展属性都会被复制。</p>
<blockquote>
<p>Once the copy_up is complete, the overlay filesystem simply provides direct access to the newly created file in the upper filesystem - future operations on the file are barely noticed by the overlay filesystem (though an operation on the name of the file such as rename or unlink will of course be noticed and handled).</p>
</blockquote>
<p>一旦 copy_up 完成，覆盖文件系统只提供对上层文件系统中新创建的文件的直接访问 - 覆盖文件系统几乎不会注意到未来对该文件的操作（尽管对文件名的操作，例如重命名或取消链接） 当然会被注意到并处理）。</p>
<h2 id="权限模型permission-model">权限模型（Permission model）</h2>
<blockquote>
<p>Permission checking in the overlay filesystem follows these principles:</p>
<ol>
<li>
<p>permission check SHOULD return the same result before and after copy up</p>
</li>
<li>
<p>task creating the overlay mount MUST NOT gain additional privileges</p>
</li>
<li>
<p>non-mounting task MAY gain additional privileges through the overlay, compared to direct access on underlying lower or upper filesystems</p>
</li>
</ol>
</blockquote>
<p>Overlay文件系统中的权限检查遵循以下原则：</p>
<ol>
<li>
<p>权限检查应该在复制之前和之后返回相同的结果</p>
</li>
<li>
<p>创建overlay挂载的任务不得获得额外的权限</p>
</li>
<li>
<p>与直接访问底层或上层文件系统相比，非挂载任务可以通过覆盖获得额外的权限</p>
</li>
</ol>
<blockquote>
<p>This is achieved by performing two permission checks on each access</p>
<p>a. check if current task is allowed access based on local DAC (owner, group, mode and posix acl), as well as MAC checks</p>
<p>b. check if mounting task would be allowed real operation on lower or upper layer based on underlying filesystem permissions, again including MAC checks</p>
</blockquote>
<p>这是通过对每次访问执行两次权限检查来实现的</p>
<p>a. 根据本地 DAC（所有者、组、模式和 posix acl）以及 MAC 检查当前任务是否允许访问</p>
<p>b. 根据底层文件系统权限检查挂载任务是否允许在下层或上层进行实际操作，同样包括 MAC 检查</p>
<blockquote>
<p>Check (a) ensures consistency (1) since owner, group, mode and posix acls are copied up. On the other hand it can result in server enforced permissions (used by NFS, for example) being ignored (3).</p>
<p>Check (b) ensures that no task gains permissions to underlying layers that the mounting task does not have (2). This also means that it is possible to create setups where the consistency rule (1) does not hold; normally, however, the mounting task will have sufficient privileges to perform all operations.</p>
</blockquote>
<p>检查 (a) 确保一致性 (1)，因为所有者、组、模式和 posix acl 被复制。 另一方面，它可能会导致服务器强制执行的权限（例如，由 NFS 使用）被忽略 (3)。</p>
<p>检查 (b) 确保没有任务获得挂载任务所没有的底层权限（2）。 这也意味着可以创建不满足一致性规则 (1) 的设置； 但是，通常情况下，挂载任务将具有足够的权限来执行所有操作。</p>
<blockquote>
<p>Another way to demonstrate this model is drawing parallels between</p>
</blockquote>
<p>演示该模型的另一种方法是类比以下两种方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">mount -t overlay overlay -olowerdir=/lower,upperdir=/upper,... /merged
</span></span></code></pre></div><blockquote>
<p>and</p>
</blockquote>
<p>和</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">cp -a /lower /upper &amp;&amp; mount --bind /upper /merged
</span></span></code></pre></div><p>（译者注：原文是<code>cp -a /lower /upper mount --bind /upper /merged</code> , 我认为是漏了&amp;&amp;）</p>
<blockquote>
<p>The resulting access permissions should be the same. The difference is in the time of copy (on-demand vs. up-front).</p>
</blockquote>
<p>两种方式生成的访问权限应该是相同的。 区别在于发生复制的时间（按需复制与预先复制）。</p>
<h2 id="多个下层multiple-lower-layers">多个下层（Multiple lower layers）</h2>
<blockquote>
<p>Multiple lower layers can now be given using the colon (&quot;:&quot;) as a separator character between the directory names. For example:</p>
</blockquote>
<p>可以使用冒号（“：”）作为目录名称之间的分隔符来指定多个下层。 例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">mount -t overlay overlay -olowerdir=/lower1:/lower2:/lower3 /merged
</span></span></code></pre></div><blockquote>
<p>As the example shows, &quot;upperdir=&quot; and &quot;workdir=&quot; may be omitted. In that case the overlay will be read-only.</p>
<p>The specified lower directories will be stacked beginning from the rightmost one and going left. In the above example lower1 will be the top, lower2 the middle and lower3 the bottom layer.</p>
</blockquote>
<p>如示例所示，“upperdir=”和“workdir=”可以省略。 在这种情况下，overlay fs将是只读的。</p>
<p>指定的下级目录将从最右边的目录开始向左堆叠。 在上面的例子中，lower1 是顶层，lower2 是中间层，lower3 是底层。</p>
<h2 id="仅向上拷贝元数据-metadata-only-copy-up">仅向上拷贝元数据 (Metadata only copy up)</h2>
<blockquote>
<p>When metadata only copy up feature is enabled, overlayfs will only copy up metadata (as opposed to whole file), when a metadata specific operation like chown/chmod is performed. Full file will be copied up later when file is opened for WRITE operation.</p>
<p>In other words, this is delayed data copy up operation and data is copied up when there is a need to actually modify data.</p>
</blockquote>
<p>当启用仅向上拷贝元数据功能时，当执行 chown/chmod 等元数据特定操作时，overlayfs 将仅复制元数据（而不是整个文件）。 当文件打开进行写操作时，完整的文件将被复制。</p>
<p>换句话说，这是延迟数据复制操作，当需要实际修改数据时才复制数据。</p>
<blockquote>
<p>There are multiple ways to enable/disable this feature. A config option CONFIG_OVERLAY_FS_METACOPY can be set/unset to enable/disable this feature by default. Or one can enable/disable it at module load time with module parameter metacopy=on/off. Lastly, there is also a per mount option metacopy=on/off to enable/disable this feature per mount.</p>
</blockquote>
<p>有多种方法可以启用/禁用此功能。 可以通过设置/取消设置配置选项 CONFIG_OVERLAY_FS_METACOPY 以默认启用/禁用此功能。 或者可以在模块加载时使用模块参数 metacopy=on/off 启用/禁用它。 最后，可以在每个挂载时指定挂载选项 metacopy=on/off 来启用/禁用功能。</p>
<blockquote>
<p>Do not use metacopy=on with untrusted upper/lower directories. Otherwise it is possible that an attacker can create a handcrafted file with appropriate REDIRECT and METACOPY xattrs, and gain access to file on lower pointed by REDIRECT. This should not be possible on local system as setting &quot;trusted.&quot; xattrs will require CAP_SYS_ADMIN. But it should be possible for untrusted layers like from a pen drive.</p>
</blockquote>
<p>不要对不受信任的上层/下层目录使用metacopy=on。 否则，攻击者可能会使用适当的 REDIRECT 和 METACOPY xattrs 手工创建文件，并获得 REDIRECT 指向的下层文件的访问权限。 这在本地系统上应该是不可能的，因为设置&quot;trusted.&quot; xattrs 将需要 CAP_SYS_ADMIN 权限。 但对于不受信任的层（例如pen drive）应该是可能的。</p>
<blockquote>
<p>Note: redirect_dir={off|nofollow|follow[*]} and nfs_export=on mount options conflict with metacopy=on, and will result in an error.</p>
<p>[*] redirect_dir=follow only conflicts with metacopy=on if upperdir=... is given.</p>
</blockquote>
<p>注意：redirect_dir={off|nofollow|follow[*]} 和 nfs_export=on 挂载选项与 metacopy=on 冲突，并会导致错误。</p>
<p>[*] 如果给出了 upperdir=...，redirect_dir=follow 仅与 metacopy=on 冲突。</p>
<h2 id="只含数据的下层data-only-lower-layers">只含数据的下层（Data-only lower layers）</h2>
<blockquote>
<p>With &quot;metacopy&quot; feature enabled, an overlayfs regular file may be a composition of information from up to three different layers:</p>
<ol>
<li>metadata from a file in the upper layer</li>
<li>st_ino and st_dev object identifier from a file in a lower layer</li>
<li>data from a file in another lower layer (further below)</li>
</ol>
</blockquote>
<p>启用“元复制”功能后，overlayfs 常规文件可能是来自最多三个不同层的信息的组合：</p>
<ol>
<li>来自上层文件的元数据</li>
<li>下层文件中的 st_ino 和 st_dev 对象标识符</li>
<li>来自另一个下层（更下面）的文件的数据</li>
</ol>
<blockquote>
<p>The &quot;lower data&quot; file can be on any lower layer, except from the top most lower layer.</p>
<p>Below the top most lower layer, any number of lower most layers may be defined as &quot;data-only&quot; lower layers, using double colon (&quot;::&quot;) separators. A normal lower layer is not allowed to be below a data-only layer, so single colon separators are not allowed to the right of double colon (&quot;::&quot;) separators.</p>
<p>For example:</p>
</blockquote>
<p>“下层数据”文件可以位于任何下层，除了最顶层的下层。</p>
<p>在最顶层的下层之下，可以使用双冒号（“::”）分隔符将任意数量的最下层定义为“仅数据”下层。 普通下层不允许位于“仅数据”层下方，因此单冒号分隔符不允许位于双冒号（“::”）分隔符的右侧。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">mount -t overlay overlay -olowerdir=/l1:/l2:/l3::/do1::/do2 /merged
</span></span></code></pre></div><blockquote>
<p>The paths of files in the &quot;data-only&quot; lower layers are not visible in the merged overlayfs directories and the metadata and st_ino/st_dev of files in the &quot;data-only&quot; lower layers are not visible in overlayfs inodes.</p>
<p>Only the data of the files in the &quot;data-only&quot; lower layers may be visible when a &quot;metacopy&quot; file in one of the lower layers above it, has a &quot;redirect&quot; to the absolute path of the &quot;lower data&quot; file in the &quot;data-only&quot; lower layer.</p>
</blockquote>
<p>“仅数据”下层中的文件路径在合并的overlayfs目录中不可见，并且“仅数据”下层中的文件的元数据和st_ino/st_dev在overlayfs inode中不可见。</p>
<p>当其上方的下层之一中的“元复制”文件，“重定向”到了“仅数据”下层中的“下层数据”文件的绝对路径时，“仅数据”下层中的文件的数据才有可能是可见的。</p>
<h2 id="共享和复制层sharing-and-copying-layers">共享和复制层（Sharing and copying layers）</h2>
<blockquote>
<p>Lower layers may be shared among several overlay mounts and that is indeed a very common practice. An overlay mount may use the same lower layer path as another overlay mount and it may use a lower layer path that is beneath or above the path of another overlay lower layer path.</p>
<p>Using an upper layer path and/or a workdir path that are already used by another overlay mount is not allowed and may fail with EBUSY. Using partially overlapping paths is not allowed and may fail with EBUSY. If files are accessed from two overlayfs mounts which share or overlap the upper layer and/or workdir path the behavior of the overlay is undefined, though it will not result in a crash or deadlock.</p>
<p>Mounting an overlay using an upper layer path, where the upper layer path was previously used by another mounted overlay in combination with a different lower layer path, is allowed, unless the &quot;inodes index&quot; feature or &quot;metadata only copy up&quot; feature is enabled.</p>
</blockquote>
<p>下层可以在多个overlay挂载之间共享，这其实是一种非常常见的做法。 一个overlay挂载可以使用与另一个overlay挂载相同的下层路径，并且它可以使用在另一个overlay下层路径之下或之上的下层路径。</p>
<p>不允许使用已被另一个overlay挂载使用的上层路径和/或 workdir 路径，并且可能会返回 EBUSY 错误。 不允许使用部分重叠的路径，它可能返回 EBUSY 错误。 如果从共享或重叠上层和/或workdir路径的两个overlayfs挂载访问文件，则覆盖的行为是未定义的，尽管它不会导致崩溃或死锁。</p>
<p>使用某一个上层路径挂载overlay，这个上层路径先前已经与不同的下层路径组合起来，被另一个挂载的overlay使用过了，这种情况是被允许的，除非启用了“inode 索引”功能或“仅向上复制元数据”功能 。</p>
<blockquote>
<p>With the &quot;inodes index&quot; feature, on the first time mount, an NFS file handle of the lower layer root directory, along with the UUID of the lower filesystem, are encoded and stored in the &quot;trusted.overlay.origin&quot; extended attribute on the upper layer root directory. On subsequent mount attempts, the lower root directory file handle and lower filesystem UUID are compared to the stored origin in upper root directory. On failure to verify the lower root origin, mount will fail with ESTALE. An overlayfs mount with &quot;inodes index&quot; enabled will fail with EOPNOTSUPP if the lower filesystem does not support NFS export, lower filesystem does not have a valid UUID or if the upper filesystem does not support extended attributes.</p>
<p>For &quot;metadata only copy up&quot; feature there is no verification mechanism at mount time. So if same upper is mounted with different set of lower, mount probably will succeed but expect the unexpected later on. So don't do it.</p>
<p>It is quite a common practice to copy overlay layers to a different directory tree on the same or different underlying filesystem, and even to a different machine. With the &quot;inodes index&quot; feature, trying to mount the copied layers will fail the verification of the lower root file handle.</p>
</blockquote>
<p>通过“inodes索引”功能，在第一次挂载时，下层根目录的NFS文件句柄，以及下层文件系统的UUID，被编码并存储在上层根目录的“trusted.overlay.origin”扩展属性中。 在随后的挂载尝试中，会将下层根目录文件句柄和下层文件系统 UUID 与上层根目录中存储的源进行比较。 如果无法验证较低的根原点，挂载将失败并报 ESTALE 错误。 如果下层文件系统不支持 NFS 导出、下层文件系统没有有效的 UUID 或者上层文件系统不支持扩展属性，启用“inodes 索引”的 Overlayfs 挂载将会失败并报 EOPNOTSUPP 错误。</p>
<p>对于“仅向上复制元数据”功能，挂载时没有验证机制。 因此，如果相同上层的与不同的下层一起挂载，挂载可能会成功，但稍后会出现非预期的状况。 所以不要这样做。</p>
<p>将覆盖层复制到相同或不同底层文件系统上的不同目录树，甚至复制到不同的机器是很常见的做法。 使用“inodes索引”功能，尝试挂载复制的层将无法验证较低的根文件句柄。</p>
<h2 id="非标准行为non-standard-behavior">非标准行为（Non-standard behavior）</h2>
<blockquote>
<p>Current version of overlayfs can act as a mostly POSIX compliant filesystem.</p>
<p>This is the list of cases that overlayfs doesn't currently handle:</p>
<p>a) POSIX mandates updating st_atime for reads. This is currently not done in the case when the file resides on a lower layer.</p>
<p>b) If a file residing on a lower layer is opened for read-only and then memory mapped with MAP_SHARED, then subsequent changes to the file are not reflected in the memory mapping.</p>
<p>c) If a file residing on a lower layer is being executed, then opening that file for write or truncating the file will not be denied with ETXTBSY.</p>
</blockquote>
<p>当前版本的overlayfs 文件系统可以基本兼容POSIX。</p>
<p>这是overlayfs 当前不处理的情况列表：</p>
<p>a) POSIX 强制在读文件时更新 st_atime。 当文件驻留在较低层时，当前不执行此操作。</p>
<p>b) 如果驻留在下层的文件以只读方式打开，然后使用 MAP_SHARED 映射内存，则对该文件的后续更改不会反映在内存映射中。</p>
<p>c) 如果正在执行驻留在下层的文件，则打开该文件进行写入，或截断该文件将不会被以 ETXTBSY 错误拒绝。</p>
<blockquote>
<p>The following options allow overlayfs to act more like a standards compliant filesystem:</p>
<ol>
<li>&quot;redirect_dir&quot;</li>
</ol>
<p>Enabled with the mount option or module option: &quot;redirect_dir=on&quot; or with the kernel config option CONFIG_OVERLAY_FS_REDIRECT_DIR=y.</p>
<p>If this feature is disabled, then rename(2) on a lower or merged directory will fail with EXDEV (&quot;Invalid cross-device link&quot;).</p>
</blockquote>
<p>以下选项允许overlayfs更像一个符合标准的文件系统：</p>
<ol>
<li>“重定向目录”</li>
</ol>
<p>使用挂载选项或模块选项启用：“redirect_dir=on”或使用内核配置选项 CONFIG_OVERLAY_FS_REDIRECT_DIR=y。</p>
<p>如果禁用此功能，则下层目录或合并目录上的 rename(2) 将失败并显示 EXDEV（“无效的跨设备链接”）。</p>
<blockquote>
<ol start="2">
<li>&quot;inode index&quot;</li>
</ol>
<p>Enabled with the mount option or module option &quot;index=on&quot; or with the kernel config option CONFIG_OVERLAY_FS_INDEX=y.</p>
<p>If this feature is disabled and a file with multiple hard links is copied up, then this will &quot;break&quot; the link. Changes will not be propagated to other names referring to the same inode.</p>
</blockquote>
<ol start="2">
<li>&quot;inode 索引&quot;</li>
</ol>
<p>使用挂载选项或模块选项“index=on”或使用内核配置选项 CONFIG_OVERLAY_FS_INDEX=y 启用。</p>
<p>如果禁用此功能并且复制具有多个硬链接的文件，则这将“破坏”链接。 更改不会传播到引用同一 inode 的其他名称。</p>
<blockquote>
<ol start="3">
<li>&quot;xino&quot;</li>
</ol>
<p>Enabled with the mount option &quot;xino=auto&quot; or &quot;xino=on&quot;, with the module option &quot;xino_auto=on&quot; or with the kernel config option CONFIG_OVERLAY_FS_XINO_AUTO=y. Also implicitly enabled by using the same underlying filesystem for all layers making up the overlay.</p>
<p>If this feature is disabled or the underlying filesystem doesn't have enough free bits in the inode number, then overlayfs will not be able to guarantee that the values of st_ino and st_dev returned by stat(2) and the value of d_ino returned by readdir(3) will act like on a normal filesystem. E.g. the value of st_dev may be different for two objects in the same overlay filesystem and the value of st_ino for filesystem objects may not be persistent and could change even while the overlay filesystem is mounted, as summarized in the Inode properties table above.</p>
</blockquote>
<ol start="3">
<li>“xino”</li>
</ol>
<p>通过挂载选项“xino=auto”或“xino=on”、模块选项“xino_auto=on”或内核配置选项 CONFIG_OVERLAY_FS_XINO_AUTO=y 启用。 还可以通过对构成overlay的所有层使用相同的底层文件系统来隐式启用。</p>
<p>如果禁用此功能或底层文件系统的 inode 编号中没有足够的空闲位，则overlayfs将无法保证 stat(2) 返回的 st_ino 和 st_dev 的值以及 readdir(3) 返回的 d_ino 的值与在普通文件系统上的表现一致。 例如，对于同一overlay文件系统中的两个对象，st_dev 的值可能不同，并且文件系统对象的 st_ino 值可能不是持久的，即使在Overlay文件系统还处于挂载状态时也可能会发生变化，如上面的 Inode 属性表中总结的那样。</p>
<h2 id="修改底层文件系统changes-to-underlying-filesystems">修改底层文件系统（Changes to underlying filesystems）</h2>
<blockquote>
<p>Changes to the underlying filesystems while part of a mounted overlay filesystem are not allowed. If the underlying filesystem is changed, the behavior of the overlay is undefined, though it will not result in a crash or deadlock.</p>
<p>Offline changes, when the overlay is not mounted, are allowed to the upper tree. Offline changes to the lower tree are only allowed if the &quot;metadata only copy up&quot;, &quot;inode index&quot;, &quot;xino&quot; and &quot;redirect_dir&quot; features have not been used. If the lower tree is modified and any of these features has been used, the behavior of the overlay is undefined, though it will not result in a crash or deadlock.</p>
</blockquote>
<p>不允许修改已挂载的Overlay文件系统的底层文件系统。 如果底层文件系统发生更改，则overlay fs的行为是未定义的，尽管它不会导致崩溃或死锁。</p>
<p>当未挂载overlay fs时，允许对上层树进行离线更改。 仅当未使用“仅向上复制元数据”、“inode 索引”、“xino”和“redirect_dir”功能时，才允许对下部树进行离线更改。 如果修改了较低的树并且使用了任何这些功能，则overlay的行为是未定义的，尽管它不会导致崩溃或死锁。</p>
<blockquote>
<p>When the overlay NFS export feature is enabled, overlay filesystems behavior on offline changes of the underlying lower layer is different than the behavior when NFS export is disabled.</p>
<p>On every copy_up, an NFS file handle of the lower inode, along with the UUID of the lower filesystem, are encoded and stored in an extended attribute &quot;trusted.overlay.origin&quot; on the upper inode.</p>
<p>When the NFS export feature is enabled, a lookup of a merged directory, that found a lower directory at the lookup path or at the path pointed to by the &quot;trusted.overlay.redirect&quot; extended attribute, will verify that the found lower directory file handle and lower filesystem UUID match the origin file handle that was stored at copy_up time. If a found lower directory does not match the stored origin, that directory will not be merged with the upper directory.</p>
</blockquote>
<p>当启用overlay NFS 导出功能时，overlay文件系统对底层较低层的离线更改的行为与禁用 NFS 导出时的行为不同。</p>
<p>每次的向上拷贝（copy_up），下层 inode 的 NFS 文件句柄以及下层文件系统的 UUID 都被编码并存储在上层 inode 上的扩展属性“trusted.overlay.origin”中。</p>
<p>当启用 NFS 导出功能时，一次对合并目录的查找，如果通过路径找到下层目录，或通过“trusted.overlay.redirect”扩展属性指向的路径找到下层目录，将验证找到的下层目录文件句柄和下层文件系统 UUID 是否与 copy_up 时存储的原始文件句柄匹配。 如果找到的下级目录与存储的源不匹配，则该目录将不会与上级目录合并。</p>
<h2 id="nfs导出nfs-export">NFS导出（NFS export）</h2>
<blockquote>
<p>When the underlying filesystems supports NFS export and the &quot;nfs_export&quot; feature is enabled, an overlay filesystem may be exported to NFS.</p>
<p>With the &quot;nfs_export&quot; feature, on copy_up of any lower object, an index entry is created under the index directory. The index entry name is the hexadecimal representation of the copy up origin file handle. For a non-directory object, the index entry is a hard link to the upper inode. For a directory object, the index entry has an extended attribute &quot;trusted.overlay.upper&quot; with an encoded file handle of the upper directory inode.</p>
<p>When encoding a file handle from an overlay filesystem object, the following rules apply:</p>
<ol>
<li>For a non-upper object, encode a lower file handle from lower inode</li>
<li>For an indexed object, encode a lower file handle from copy_up origin</li>
<li>For a pure-upper object and for an existing non-indexed upper object, encode an upper file handle from upper inode</li>
</ol>
</blockquote>
<p>当底层文件系统支持 NFS 导出并且启用“nfs_export”功能时，可以将overlay文件系统导出到 NFS。</p>
<p>使用“nfs_export”功能，在复制任何下层对象时，会在索引目录下创建索引条目。 索引条目名称是复制源文件句柄的十六进制表示形式。 对于非目录对象，索引项是到上层 inode 的硬链接。 对于目录对象，索引条目具有扩展属性“trusted.overlay.upper”，其中包含上层目录 inode 的编码文件句柄。</p>
<p>当从overlay文件系统对象编码文件句柄时，适用以下规则：</p>
<ol>
<li>对于非上层对象，从下层inode编码出下层文件句柄</li>
<li>对于索引对象，从 copy_up 源编码下层文件句柄</li>
<li>对于纯上层对象和现有的非索引上层对象，从上层 inode 编码上层文件句柄</li>
</ol>
<blockquote>
<p>The encoded overlay file handle includes:</p>
<ul>
<li>Header including path type information (e.g. lower/upper)</li>
<li>UUID of the underlying filesystem</li>
<li>Underlying filesystem encoding of underlying inode</li>
</ul>
<p>This encoding format is identical to the encoding format file handles that are stored in extended attribute &quot;trusted.overlay.origin&quot;.</p>
</blockquote>
<p>编码的overlay文件句柄包括：</p>
<ul>
<li>包含路径类型信息的标头（例如下层/上层）</li>
<li>下层文件系统的UUID</li>
<li>下层 inode 的底层文件系统编码</li>
</ul>
<p>此编码格式与存储在扩展属性“trusted.overlay.origin”中的文件句柄编码格式相同。</p>
<blockquote>
<p>When decoding an overlay file handle, the following steps are followed:</p>
<ol>
<li>Find underlying layer by UUID and path type information.</li>
<li>Decode the underlying filesystem file handle to underlying dentry.</li>
<li>For a lower file handle, lookup the handle in index directory by name.</li>
<li>If a whiteout is found in index, return ESTALE. This represents an overlay object that was deleted after its file handle was encoded.</li>
<li>For a non-directory, instantiate a disconnected overlay dentry from the decoded underlying dentry, the path type and index inode, if found.</li>
<li>For a directory, use the connected underlying decoded dentry, path type and index, to lookup a connected overlay dentry.</li>
</ol>
</blockquote>
<p>解码overlay文件句柄时，遵循以下步骤：</p>
<ol>
<li>通过UUID和路径类型信息找到下层。</li>
<li>将下层文件系统文件句柄解码为下层dentry（目录项）。</li>
<li>对于下层文件句柄，在索引目录中按名称查找该句柄。</li>
<li>如果在索引中发现whiteout，则返回 ESTALE。 这代表其文件句柄编码后overlay对象被删除。</li>
<li>对于非目录，从解码的底层目录项、路径类型和索引 inode实例化断开连接的overlay dentry（如果找到）。</li>
<li>对于目录，使用连接的底层解码目录项、路径类型和索引来查找连接的overlay dentry。</li>
</ol>
<blockquote>
<p>Decoding a non-directory file handle may return a disconnected dentry. copy_up of that disconnected dentry will create an upper index entry with no upper alias.</p>
<p>When overlay filesystem has multiple lower layers, a middle layer directory may have a &quot;redirect&quot; to lower directory. Because middle layer &quot;redirects&quot; are not indexed, a lower file handle that was encoded from the &quot;redirect&quot; origin directory, cannot be used to find the middle or upper layer directory. Similarly, a lower file handle that was encoded from a descendant of the &quot;redirect&quot; origin directory, cannot be used to reconstruct a connected overlay path. To mitigate the cases of directories that cannot be decoded from a lower file handle, these directories are copied up on encode and encoded as an upper file handle. On an overlay filesystem with no upper layer this mitigation cannot be used NFS export in this setup requires turning off redirect follow (e.g. &quot;redirect_dir=nofollow&quot;).</p>
</blockquote>
<p>解码非目录文件句柄可能会返回断开连接的目录项。 该断开连接的 dentry 的 copy_up 将创建一个没有上层别名的上层索引条目。</p>
<p>当overlay文件系统具有多个下层时，中间层目录可能会“重定向”到下层目录。 因为中间层“重定向”没有索引，所以从“重定向”原始目录编码的较低文件句柄不能用于查找中间层或上层目录。 类似地，从“重定向”原始目录的后代编码的较低文件句柄不能用于重建连接的overlay路径。 为了缓解无法从较低文件句柄解码目录的情况，这些目录在编码时被复制并编码为较高层文件句柄。 在没有上层的覆盖文件系统上，无法使用此缓解措施。此设置中的 NFS 导出需要关闭重定向跟踪（例如“redirect_dir=nofollow”）。</p>
<blockquote>
<p>The overlay filesystem does not support non-directory connectable file handles, so exporting with the 'subtree_check' exportfs configuration will cause failures to lookup files over NFS.</p>
<p>When the NFS export feature is enabled, all directory index entries are verified on mount time to check that upper file handles are not stale. This verification may cause significant overhead in some cases.</p>
<p>Note: the mount options index=off,nfs_export=on are conflicting for a read-write mount and will result in an error.</p>
<p>Note: the mount option uuid=off can be used to replace UUID of the underlying filesystem in file handles with null, and effectively disable UUID checks. This can be useful in case the underlying disk is copied and the UUID of this copy is changed. This is only applicable if all lower/upper/work directories are on the same filesystem, otherwise it will fallback to normal behaviour.</p>
</blockquote>
<p>覆盖文件系统不支持非目录可连接文件句柄，因此使用“subtree_check”exportfs 配置导出将导致通过 NFS 查找文件失败。</p>
<p>启用 NFS 导出功能后，所有目录索引条目都会在挂载时进行验证，以检查上层文件句柄是否已过时。 在某些情况下，此验证可能会导致显著的开销。</p>
<p>注意：挂载选项index=off,nfs_export=on对于读写挂载是冲突的，并且会导致错误。</p>
<p>注意：挂载选项 uuid=off 可用于将文件句柄中底层文件系统的 UUID 替换为 null，并有效禁用 UUID 检查。 如果复制了下层磁盘并且该副本的 UUID 发生了更改，这会很有用。 仅当所有下层/上层/工作目录位于同一文件系统上时才适用，否则它将恢复正常行为。</p>
<h2 id="易失性挂载volatile-mount">易失性挂载（Volatile mount）</h2>
<blockquote>
<p>This is enabled with the &quot;volatile&quot; mount option. Volatile mounts are not guaranteed to survive a crash. It is strongly recommended that volatile mounts are only used if data written to the overlay can be recreated without significant effort.</p>
<p>The advantage of mounting with the &quot;volatile&quot; option is that all forms of sync calls to the upper filesystem are omitted.</p>
</blockquote>
<p>这是通过“易失性”挂载选项启用的。无法保证易失性挂载能够在崩溃中幸存下来。 强烈建议仅当无需付出很大努力即可重新创建写入overlay fs的数据时，才使用易失性挂载。</p>
<p>使用“易失性”选项挂载的优点是省略了对上层文件系统的所有形式的sync调用。</p>
<blockquote>
<p>In order to avoid a giving a false sense of safety, the syncfs (and fsync) semantics of volatile mounts are slightly different than that of the rest of VFS. If any writeback error occurs on the upperdir's filesystem after a volatile mount takes place, all sync functions will return an error. Once this condition is reached, the filesystem will not recover, and every subsequent sync call will return an error, even if the upperdir has not experience a new error since the last sync call.</p>
<p>When overlay is mounted with &quot;volatile&quot; option, the directory &quot;$workdir/work/incompat/volatile&quot; is created. During next mount, overlay checks for this directory and refuses to mount if present. This is a strong indicator that user should throw away upper and work directories and create fresh one. In very limited cases where the user knows that the system has not crashed and contents of upperdir are intact, The &quot;volatile&quot; directory can be removed.</p>
</blockquote>
<p>为了避免给人一种错误的安全感，易失性挂载的syncfs（和fsync）语义与VFS其余部分的语义略有不同。 如果在易失性挂载上层目录的文件系统上发生任何回写错误，则所有sync函数都将返回错误。 一旦达到此条件，文件系统将无法恢复，并且每个后续sync调用都将返回错误，即使上层目录自上次sync调用以来没有遇到新错误也是如此。</p>
<p>当使用“易失性”选项挂载overlay时，将创建目录“$workdir/work/incompat/volatile”。 在下次挂载时，overlay检查此目录并拒绝挂载（如果存在）。 这是一个强有力的指标，表明用户应该丢弃上层目录和工作目录并创建新的目录。 在非常有限的情况下，用户知道系统没有崩溃并且上层目录的内容完好无损，可以删除“volatile”目录。</p>
<h2 id="用户扩展属性user-xattr">用户扩展属性（User xattr）</h2>
<blockquote>
<p>The &quot;-o userxattr&quot; mount option forces overlayfs to use the &quot;user.overlay.&quot; xattr namespace instead of &quot;trusted.overlay.&quot;. This is useful for unprivileged mounting of overlayfs.</p>
</blockquote>
<p>“-o userxattr”挂载选项强制overlayfs使用“user.overlay.” xattr 命名空间而不是“trusted.overlay.”。 这对于非特权挂载overlayfs 很有用。</p>
<h2 id="测试套testsuite">测试套（Testsuite）</h2>
<blockquote>
<p>There's a testsuite originally developed by David Howells and currently maintained by Amir Goldstein at:</p>
</blockquote>
<p>有一个测试套件最初由 David Howells 开发，目前由 Amir Goldstein 维护，网址为：</p>
<p><a href="https://github.com/amir73il/unionmount-testsuite.git">https://github.com/amir73il/unionmount-testsuite.git</a></p>
<blockquote>
<p>Run as root:</p>
</blockquote>
<p>以Root用户运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl"># cd unionmount-testsuite
</span></span><span class="line"><span class="ln">2</span><span class="cl"># ./run --ov --verify
</span></span></code></pre></div>
    </div>
<div class="post_comments">
  
  
    
 <script src="https://utteranc.es/client.js"
         repo="weizhang555/weizhang555.github.io"
         issue-term="title"
         theme="github-light"
         
         label="blog comments ✨💬✨"
         
         crossorigin="anonymous"
         async>
 </script>
 
  
  
</div>




  </article>
<aside class="sidebar">
  <section class="sidebar_inner">
    <br>
    
  
  <div class="search">
    <input type="search" class="search_field form_field" placeholder='Search...' id="find" autocomplete="off" data-scope='translate'>
    <label for="find" class="search_label"><svg class="icon">
  <title>search</title>
  <use xlink:href="#search"></use>
</svg>

    </label>
    
    <div class="search_results results"></div>
  </div>

        <h2>张伟[weizhang555]</h2>
      <div class="author_bio">
        一个简简单单的技术人.</br>Live long and prosper!
      </div>
      <a href='https://weizhang555.github.io/about/' class="button mt-1" role="button" title='Read More'>Read More</a>

    
    
    <h2 class="mt-4">Recent Posts</h2>
    <ul class="flex-column">
      <li>
        <a href="https://weizhang555.github.io/original/tdx-trust-chain/" class="nav-link" title="基于Intel TDX的机密容器（CoCo）安全性分析">基于Intel TDX的机密容器（CoCo）安全性分析</a>
      </li>
      <li>
        <a href="https://weizhang555.github.io/original/k8s-setup-2/" class="nav-link" title="kubeadm拉起单节点K8s(新版)">kubeadm拉起单节点K8s(新版)</a>
      </li>
      <li>
        <a href="https://weizhang555.github.io/translate/linux-overlayfs/" class="nav-link" title="[内核文档翻译] Overlay文件系统">[内核文档翻译] Overlay文件系统</a>
      </li>
      <li>
        <a href="https://weizhang555.github.io/translate/whats-good-engineer/" class="nav-link" title="防火不如救火，治未病不如治已病，好代码不如好吆喝">防火不如救火，治未病不如治已病，好代码不如好吆喝</a>
      </li>
      <li>
        <a href="https://weizhang555.github.io/translate/using-bpf-ringbuffer/" class="nav-link" title="使用BPF ring buffer">使用BPF ring buffer</a>
      </li>
      <li>
        <a href="https://weizhang555.github.io/translate/bpf-design-qa/" class="nav-link" title="BPF的设计原则Q&amp;A">BPF的设计原则Q&amp;A</a>
      </li>
      <li>
        <a href="https://weizhang555.github.io/republish/pnp-problem/" class="nav-link" title="转载：著名的 P=NP 问题到底是什么">转载：著名的 P=NP 问题到底是什么</a>
      </li>
      <li>
        <a href="https://weizhang555.github.io/original/learn-solidity/" class="nav-link" title="Solidity入门：基于Truffle搭建本地开发环境">Solidity入门：基于Truffle搭建本地开发环境</a>
      </li>
    </ul>
    <div>
      <h2 class="mt-4 taxonomy" id="categories-section">Categories</h2>
      <nav class="tags_nav">
        <a href='https://weizhang555.github.io/categories/%E5%8E%9F%E5%88%9B/' class="post_tag button button_translucent" title="原创">
          原创
          <span class="button_tally">13</span>
        </a>
        
        <a href='https://weizhang555.github.io/categories/%E8%AF%91%E6%96%87/' class="post_tag button button_translucent" title="译文">
          译文
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://weizhang555.github.io/categories/%E8%BD%AC%E8%BD%BD/' class="post_tag button button_translucent" title="转载">
          转载
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
    <div>
      <h2 class="mt-4 taxonomy" id="tags-section">Tags</h2>
      <nav class="tags_nav">
        <a href='https://weizhang555.github.io/tags/%E5%AE%B9%E5%99%A8/' class="post_tag button button_translucent" title="容器">
          容器
          <span class="button_tally">9</span>
        </a>
        
        <a href='https://weizhang555.github.io/tags/%E5%86%85%E6%A0%B8/' class="post_tag button button_translucent" title="内核">
          内核
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://weizhang555.github.io/tags/%E5%AE%89%E5%85%A8/' class="post_tag button button_translucent" title="安全">
          安全
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://weizhang555.github.io/tags/k8s/' class="post_tag button button_translucent" title="k8s">
          K8S
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://weizhang555.github.io/tags/bpf/' class="post_tag button button_translucent" title="bpf">
          BPF
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://weizhang555.github.io/tags/%E9%9A%8F%E7%AC%94/' class="post_tag button button_translucent" title="随笔">
          随笔
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://weizhang555.github.io/tags/coco/' class="post_tag button button_translucent" title="coco">
          COCO
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://weizhang555.github.io/tags/go/' class="post_tag button button_translucent" title="go">
          GO
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://weizhang555.github.io/tags/kata/' class="post_tag button button_translucent" title="kata">
          KATA
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://weizhang555.github.io/tags/pnp/' class="post_tag button button_translucent" title="p&amp;np">
          P&amp;NP
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://weizhang555.github.io/tags/runc/' class="post_tag button button_translucent" title="runc">
          RUNC
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://weizhang555.github.io/tags/tdx/' class="post_tag button button_translucent" title="tdx">
          TDX
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://weizhang555.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/' class="post_tag button button_translucent" title="区块链">
          区块链
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://weizhang555.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/' class="post_tag button button_translucent" title="机密计算">
          机密计算
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
  </section>
</aside>

  
</div>
    </main><svg width="0" height="0" class="hidden">
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="facebook">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h151V331h-60v-90h60v-61c0-49.629 40.371-90 90-90h91v90h-91v61h91l-15 90h-76v181h121c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.001 18.001" id="twitter">
    <path d="M15.891 4.013c.808-.496 1.343-1.173 1.605-2.034a8.68 8.68 0 0 1-2.351.861c-.703-.756-1.593-1.14-2.66-1.14-1.043 0-1.924.366-2.643 1.078a3.56 3.56 0 0 0-1.076 2.605c0 .309.039.585.117.819-3.076-.105-5.622-1.381-7.628-3.837-.34.601-.51 1.213-.51 1.846 0 1.301.549 2.332 1.645 3.089-.625-.053-1.176-.211-1.645-.47 0 .929.273 1.705.82 2.388a3.623 3.623 0 0 0 2.115 1.291c-.312.08-.641.118-.979.118-.312 0-.533-.026-.664-.083.23.757.664 1.371 1.291 1.841a3.652 3.652 0 0 0 2.152.743C4.148 14.173 2.625 14.69.902 14.69c-.422 0-.721-.006-.902-.038 1.697 1.102 3.586 1.649 5.676 1.649 2.139 0 4.029-.542 5.674-1.626 1.645-1.078 2.859-2.408 3.639-3.974a10.77 10.77 0 0 0 1.172-4.892v-.468a7.788 7.788 0 0 0 1.84-1.921 8.142 8.142 0 0 1-2.11.593z"
      ></path>
  </symbol>
  <symbol aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="mail">
    <path  d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="calendar">
    <path d="M452 40h-24V0h-40v40H124V0H84v40H60C26.916 40 0 66.916 0 100v352c0 33.084 26.916 60 60 60h392c33.084 0 60-26.916 60-60V100c0-33.084-26.916-60-60-60zm20 412c0 11.028-8.972 20-20 20H60c-11.028 0-20-8.972-20-20V188h432v264zm0-304H40v-48c0-11.028 8.972-20 20-20h24v40h40V80h264v40h40V80h24c11.028 0 20 8.972 20 20v48z"></path>
    <path d="M76 230h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 310h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 390h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80-80h40v40h-40z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="github">
    <path d="M255.968 5.329C114.624 5.329 0 120.401 0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384 0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008 0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992 0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584 0 34.368-.32 62.08-.32 70.496 0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 212 212" id="gitlab">
    <path d="M12.3 74.7h54L43.3 3c-1-3.6-6.4-3.6-7.6 0L12.3 74.8z" />
    <path d="M12.3 74.7L.5 111c-1 3.2 0 6.8 3 8.8l101.6 74-92.5-119z"/>
    <path d="M105 193.7l-38.6-119h-54l92.7 119z"/>
    <path d="M105 193.7l38.7-119H66.4l38.7 119z"/>
    <path d="M105 193.7l38.7-119H198l-93 119z"/>
    <path d="M198 74.7l11.6 36.2c1 3 0 6.6-3 8.6l-101.5 74 93-119z"/>
    <path d="M198 74.7h-54.3L167 3c1.2-3.6 6.4-3.6 7.6 0L198 74.8z"/>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="rss">
    <circle cx="3.429" cy="20.571" r="3.429"></circle>
    <path d="M11.429 24h4.57C15.999 15.179 8.821 8.001 0 8v4.572c6.302.001 11.429 5.126 11.429 11.428z"></path>
    <path d="M24 24C24 10.766 13.234 0 0 0v4.571c10.714 0 19.43 8.714 19.43 19.429z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="linkedin">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h362c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zM181 406h-60V196h60zm0-240h-60v-60h60zm210 240h-60V286c0-16.54-13.46-30-30-30s-30 13.46-30 30v120h-60V196h60v11.309C286.719 202.422 296.93 196 316 196c40.691.043 75 36.547 75 79.688zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612" id="to-top">
    <path d="M604.501 440.509L325.398 134.956c-5.331-5.357-12.423-7.627-19.386-7.27-6.989-.357-14.056 1.913-19.387 7.27L7.499 440.509c-9.999 10.024-9.999 26.298 0 36.323s26.223 10.024 36.222 0l262.293-287.164L568.28 476.832c9.999 10.024 26.222 10.024 36.221 0 9.999-10.023 9.999-26.298 0-36.323z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="carly">
    <path d="M504.971 239.029L448 182.059V84c0-46.317-37.682-84-84-84h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c19.851 0 36 16.149 36 36v108c0 6.365 2.529 12.47 7.029 16.971L454.059 256l-47.029 47.029A24.002 24.002 0 0 0 400 320v108c0 19.851-16.149 36-36 36h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c46.318 0 84-37.683 84-84v-98.059l56.971-56.971c9.372-9.372 9.372-24.568 0-33.941zM112 192V84c0-19.851 16.149-36 36-36h44c13.255 0 24-10.745 24-24S205.255 0 192 0h-44c-46.318 0-84 37.683-84 84v98.059l-56.971 56.97c-9.373 9.373-9.373 24.568 0 33.941L64 329.941V428c0 46.317 37.682 84 84 84h44c13.255 0 24-10.745 24-24s-10.745-24-24-24h-44c-19.851 0-36-16.149-36-36V320c0-6.365-2.529-12.47-7.029-16.971L57.941 256l47.029-47.029A24.002 24.002 0 0 0 112 192z"></path>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="copy">
    <path d="M23 2.75A2.75 2.75 0 0 0 20.25 0H8.75A2.75 2.75 0 0 0 6 2.75v13.5A2.75 2.75 0 0 0 8.75 19h11.5A2.75 2.75 0 0 0 23 16.25zM18.25 14.5h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5z"></path>
    <path d="M8.75 20.5a4.255 4.255 0 0 1-4.25-4.25V2.75c0-.086.02-.166.025-.25H3.75A2.752 2.752 0 0 0 1 5.25v16A2.752 2.752 0 0 0 3.75 24h12a2.752 2.752 0 0 0 2.75-2.75v-.75z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.001 512.001" id="closeme">
    <path d="M284.286 256.002L506.143 34.144c7.811-7.811 7.811-20.475 0-28.285-7.811-7.81-20.475-7.811-28.285 0L256 227.717 34.143 5.859c-7.811-7.811-20.475-7.811-28.285 0-7.81 7.811-7.811 20.475 0 28.285l221.857 221.857L5.858 477.859c-7.811 7.811-7.811 20.475 0 28.285a19.938 19.938 0 0 0 14.143 5.857 19.94 19.94 0 0 0 14.143-5.857L256 284.287l221.857 221.857c3.905 3.905 9.024 5.857 14.143 5.857s10.237-1.952 14.143-5.857c7.811-7.811 7.811-20.475 0-28.285L284.286 256.002z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="open-menu">
    <path d="M492 236H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0-160H20C8.954 76 0 84.954 0 96s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0 320H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="instagram">
    <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id=youtube>
    <path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="stackoverflow">
    <path d="M21 27v-8h3v11H0V19h3v8h18z"></path><path d="M17.1.2L15 1.8l7.9 10.6 2.1-1.6L17.1.2zm3.7 14.7L10.6 6.4l1.7-2 10.2 8.5-1.7 2zM7.2 12.3l12 5.6 1.1-2.4-12-5.6-1.1 2.4zm-1.8 6.8l13.56 1.96.17-2.38-13.26-2.55-.47 2.97zM19 25H5v-3h14v3z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="xing">
    <path d="M18.188 0c-.517 0-.741.325-.927.66 0 0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211 0 .375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016 0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894 0 21.686 0h-3.498zM3.648 4.74c-.211 0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016 0 .021L1.86 16.051c-.099.188-.093.381 0 .529.085.142.239.234.45.234h3.461c.518 0 .766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 71 55" id="discord">
    <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 17 18" id="mastodon">
    <path
    fill="#ffffff"
    d="m 15.054695,9.8859583 c -0.22611,1.1632697 -2.02517,2.4363497 -4.09138,2.6830797 -1.0774504,0.12856 -2.1382704,0.24673 -3.2694704,0.19484 -1.84996,-0.0848 -3.30971,-0.44157 -3.30971,-0.44157 0,0.1801 0.0111,0.35157 0.0333,0.51194 0.24051,1.82571 1.81034,1.93508 3.29737,1.98607 1.50088,0.0514 2.8373104,-0.37004 2.8373104,-0.37004 l 0.0617,1.35686 c 0,0 -1.0498104,0.56374 -2.9199404,0.66742 -1.03124,0.0567 -2.3117,-0.0259 -3.80308,-0.42069 -3.23454998,-0.85613 -3.79081998,-4.304 -3.87592998,-7.8024197 -0.026,-1.03871 -0.01,-2.01815 -0.01,-2.83732 0,-3.57732 2.34385998,-4.62587996 2.34385998,-4.62587996 1.18184,-0.54277 3.20976,-0.77101 5.318,-0.7882499985409 h 0.0518 C 9.8267646,0.01719834 11.856025,0.24547834 13.037775,0.78824834 c 0,0 2.34377,1.04855996 2.34377,4.62587996 0,0 0.0294,2.63937 -0.32687,4.47183"/>
 <path
    fill="#000000"
    d="m 12.616925,5.6916583 v 4.3315297 h -1.71607 V 5.8189683 c 0,-0.88624 -0.37289,-1.33607 -1.1187604,-1.33607 -0.82467,0 -1.23799,0.53361 -1.23799,1.58875 v 2.30122 h -1.70594 v -2.30122 c 0,-1.05514 -0.4134,-1.58875 -1.23808,-1.58875 -0.74587,0 -1.11876,0.44983 -1.11876,1.33607 v 4.2042197 h -1.71607 V 5.6916583 c 0,-0.88527 0.22541,-1.58876 0.67817,-2.10922 0.46689,-0.52047 1.07833,-0.78727 1.83735,-0.78727 0.87816,0 1.54317,0.33752 1.98288,1.01267 l 0.42744,0.71655 0.42753,-0.71655 c 0.43961,-0.67515 1.10463,-1.01267 1.9828704,-1.01267 0.75893,0 1.37037,0.2668 1.83735,0.78727 0.45268,0.52046 0.67808,1.22395 0.67808,2.10922"/>
  </symbol>
</svg>

<footer class="footer">
  <div class="footer_inner wrap pale">
    <img src='https://weizhang555.github.io/icons/apple-touch-icon.png' class="icon icon_2 transparent" alt=" © Zhang Wei(weizhang555)">
    <p>Copyright&nbsp;<span class="year"></span>&nbsp; © ZHANG WEI(WEIZHANG555). All Rights Reserved</p><a class="to_top" href="#documentTop">
  <svg class="icon">
  <title>to-top</title>
  <use xlink:href="#to-top"></use>
</svg>

</a>

  </div>
</footer>

<script type="text/javascript" src="https://weizhang555.github.io/en/js/bundle.bbf6eab9d0e31d2d45a0d302b93cfbdd7c169deb9518a671024c06b869cc688d310d3e3d6f813aade70aa8dfb8f5b467207588efc0b8a721cbeeb3e059b229da.js" integrity="sha512-u/bqudDjHS1FoNMCuTz73XwWneuVGKZxAkwGuGnMaI0xDT49b4E6recKqN&#43;49bRnIHWI78C4pyHL7rPgWbIp2g==" crossorigin="anonymous"></script>

  <script src="https://weizhang555.github.io/js/search.min.73cb82d8f274395dd220d6594053cd3d3d8ac8c97d874b5142a60b9744f3704d765551e0ade104d5803c66b731f5a7a00ac2cff33c8c9090ff8100169a3e2574.js"></script>

  </body>
</html>
