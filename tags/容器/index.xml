<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>容器 on WeiZhang555</title>
    <link>https://weizhang555.github.io/tags/%E5%AE%B9%E5%99%A8/</link>
    <description>Recent content in 容器 on WeiZhang555</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright> © Zhang Wei(weizhang555)</copyright>
    <lastBuildDate>Fri, 02 Feb 2024 00:21:15 +0800</lastBuildDate><atom:link href="https://weizhang555.github.io/tags/%E5%AE%B9%E5%99%A8/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>基于Intel TDX的机密容器（CoCo）安全性分析</title>
      <link>https://weizhang555.github.io/original/tdx-trust-chain/</link>
      <pubDate>Fri, 02 Feb 2024 00:21:15 +0800</pubDate>
      
      <guid>https://weizhang555.github.io/original/tdx-trust-chain/</guid>
      <description>
        
          
            随着公有云的推广，云上的安全问题也越来越受到关注。在云上运行的应用，尤其是一些数据敏感的应用，对数据在计算过程中的机密性也越发重视。磁盘和网络的数据加密有较多的方案来处理，计算的机密性则强依赖硬件提供的安全能力。两大CPU厂商，Intel和AMD，都提供了一些硬件安全技术，如Intel的SGX和TDX，AMD的SEV等来解决此类问题。
本文将基于Intel TDX技术，来分析Confidential Contianers（简称CoCo）项目的安全性。CoCo项目是一个开源项目，它基于流行的Kata Containers项目做了增强，在其上增加了机密计算能力，安全性从单向保护（防止基础设施受到上层workload侵害），扩展到了双向保护（同时可以保护workload免受基础设施窥探）。
本文将介绍Intel TDX的可信启动流程，串联到CoCo的启动流程，进而通过信任链的传递角度来分析CoCo及TDX的安全性。
本文对阅读对象做了如下假设：
了解TDX是什么，应用于什么场景，对TDX有至少一定的了解。 听说过CoCo项目，大致知道CoCo是什么，应用于什么场景。 了解Kata Containers是什么，对Kata Containers有一定了解。 基于以上假设，本文不对CoCo和TDX做太多科普工作，前置知识的获得交给用户自己去完成。本文着重来分析CoCo的可信链条，对应的源码仓库在参考文档中有给出。
以下是正文。
TDX基本介绍 Intel给CPU加了个新的模式，叫SEAM （安全仲裁模式，Secure-Arbitration Mode, SEAM），执行 Intel 提供的、经过数字签名但未加密的安全服务模块，Intel TDX 模块位于由 SEAM-range 寄存器（SEAMRR）指定的保留内存空间中，CPU 仅允许访问SEAM模式的软件访问这段内容，其他所有软件和 DMA 都无法访问。SEAM 对其他受保护的区域如 SMM 和 SGX 保护的内存没有访问权限。
增加了SEAM mode之后，原先的VMM的模式从2个扩展到4个：
VMX-root VMX-non-root SEAM-VMX-root（新增） SEAM-VMX-non-root（新增） Intel TDX 为 TD 提供了以下功能：
内存机密性和完整性（MKTME private key加密内存） 地址转换完整性（secure EPT） CPU 状态机密性和完整性(寄存器状态 &amp;amp; VMCS 保存与恢复) 安全中断和异常传递(virtual APIC) 远程认证（remote attestation） 具体参考whitepaper，不详细展开了。
加载SEAMLDR及TDX module TDX功能的启用始于Intel TDX模块，信任根在于CPU。
Intel TDX module加载流程如下：
加载Intel TXTSEAM loader（SEAMLDR）: SEAM loader是由Intel TXT认证过的代码模块（Authenticated-Code Module, ACM） SEAMLDR可以集成在UEFI里，也可以放在ESP或磁盘上，后面会展开 VMM调用SEAMLDR ACM, 请求load TDX module。TDX module也可以在BIOS到kernel启动阶段完成。 SEAMLDR 验证TDX module数字签名，加载TDX module到SEAM memory。 TDX module的度量值（measurement）和安全版本号(security-version number, SVN)被SEAMLDR记录到硬件度量寄存器中，然后TDX module 被load到SEAM memory内。 原文来自whitepaper[1]：
          
          
        
      </description>
    </item>
    
    <item>
      <title>kubeadm拉起单节点K8s(新版)</title>
      <link>https://weizhang555.github.io/original/k8s-setup-2/</link>
      <pubDate>Tue, 17 Oct 2023 20:18:00 +0800</pubDate>
      
      <guid>https://weizhang555.github.io/original/k8s-setup-2/</guid>
      <description>
        
          
            由于国内网络环境特殊，使用kubeadm拉起K8s集群也变成了一件有技巧的事情。
本文介绍如何“科学”的使用kubeadm拉起一个单节点的K8s集群。
主要还是参考官网：https://kubernetes.io/docs/setup/
1.安装容器运行时 参考
容器运行时：https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/ 结论：此处我们选用containerd，cgroup驱动选择systemd，cgroup v2/v1我们不做偏好设置。
1.1 设置Docker repo source 1sudo apt-get update &amp;amp;&amp;amp; apt-get install \ 2 ca-certificates \ 3 curl \ 4 gnupg \ 5 lsb-release 6curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 7echo &amp;#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&amp;#34; | sudo tee /etc/apt/sources.list.d/docker.list &amp;gt; /dev/null 8sudo apt-update 1.2 安装containerd 查看containerd可用版本（可选）。
1apt-cache madison containerd.io 2apt-mark hold containerd.io 安装containerd。
1sudo apt install -y containerd.
          
          
        
      </description>
    </item>
    
    <item>
      <title>docker-runc主机逃逸漏洞复现：CVE-2019-5736</title>
      <link>https://weizhang555.github.io/original/runc-host-escape-cve/</link>
      <pubDate>Wed, 11 Dec 2019 11:30:46 +0800</pubDate>
      
      <guid>https://weizhang555.github.io/original/runc-host-escape-cve/</guid>
      <description>
        
          
            CVE-2019-5736是一个比较知名的runc漏洞，利用方式简单，危害很大，经常被拿来做云原生安全的攻击/防御演示。
我最近也研究了下这个漏洞的使用，研究的第一步首先是复现。
尝试了github上的示例： https://github.com/Frichetten/CVE-2019-5736-PoC ， 这里对源码做了一些修改，在下面分享一下。
注意：ubuntu上安装的docker 18.06似乎已经打上了补丁，我手动编译了runc的1.0.0-rc5版本才成功复现。
复现方式：
在一个terminal里面：
1zhangwei@zhangwei-ubuntu-vm:~/program/gocode/src/github.com/Frichetten/CVE-2019-5736-PoC$ docker run -ti -v $PWD/exploit:/exploit ubuntu:18.04 bash 另一个terminal内执行：
1$ docker exec -ti 5b28d7ab5083 /bin/sh 此时第一个terminal的打印：
1zhangwei@zhangwei-ubuntu-vm:~/program/gocode/src/github.com/Frichetten/CVE-2019-5736-PoC$ docker run -ti -v $PWD/exploit:/exploit ubuntu:18.04 bash 2root@5b28d7ab5083:/# /exploit 3[+] Overwritten /bin/sh successfully 4[+] Found the PID: 17 5[+] Successfully got the file handle 6[-]Failed to open /proc/self/fd/3: open /proc/self/fd/3: text file busy 7[+] Successfully got write handle &amp;amp;{0xc0000501e0} 8root@5b28d7ab5083:/# /tmp/下多了一个passwd文件。
Ubuntu下面没有原demo里使用的/etc/shadow文件，所以我修改成了/etc/passwd，会被copy到/tmp/目录下。
修改过的源码：
          
          
        
      </description>
    </item>
    
    <item>
      <title>kubernetes安装指南</title>
      <link>https://weizhang555.github.io/original/kubernetes-setup/</link>
      <pubDate>Wed, 11 Dec 2019 11:11:00 +0800</pubDate>
      
      <guid>https://weizhang555.github.io/original/kubernetes-setup/</guid>
      <description>
        
          
            本文介绍如何使用kubeadm安装一个简单的包含三个节点的集群。
测试环境 三台VM，分别为test-vm, test-vm-1, test-vm-2，系统是ubuntu 19.04
下载 kubernetes的安装包，官方文档用apt get的方式，由于国内被墙了没法get到，可以直接从github上下载release包。把kubeadm，kubelet, kubectl装好就够了。docker当然也要装好。
具体的安装步骤暂时略过。
配置kubelet 三台节点可以手动配置一下kubelet服务，配置方法都是一样的：
1# cat &amp;gt; /lib/systemd/system/kubelet.service &amp;lt;&amp;lt; EOF 2[Unit] 3Description=kubelet: The Kubernetes Node Agent 4Documentation=http://kubernetes.io/docs/ 5 6[Service] 7ExecStart=/usr/bin/kubelet 8Restart=always 9StartLimitInterval=0 10RestartSec=10 11 12[Install] 13WantedBy=multi-user.target 14EOF 上面就是简单的调用了下kubelet命令，实际上还有很多参数，这个不着急。因为我们是用kubeadm配置的，所以实际上生效的是kubeadm为kubelet设置的参数，kubelet的启动将依赖kubeadm设置的bootstrap配置：
1# mkdir -p /etc/systemd/system/kubelet.service.d/ 2# cat &amp;gt; /etc/systemd/system/kubelet.service.d/10-kubeadm.conf &amp;lt;&amp;lt; EOF 3[Service] 4Environment=&amp;#34;KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf&amp;#34; 5Environment=&amp;#34;KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml&amp;#34; 6# This is a file that &amp;#34;kubeadm init&amp;#34; and &amp;#34;kubeadm join&amp;#34; generates at runtime, populating the KUBELET_KUBEADM_ARGS variable dynamically 7EnvironmentFile=-/var/lib/kubelet/kubeadm-flags.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Docker官方镜像签名方案：Notary</title>
      <link>https://weizhang555.github.io/original/notary-intro/</link>
      <pubDate>Tue, 11 Dec 2018 11:20:00 +0800</pubDate>
      
      <guid>https://weizhang555.github.io/original/notary-intro/</guid>
      <description>
        
          
            1. TUF 1.1 背景 TUF是Tor项目设计出的一套安全分发软件更新的框架，Notary是TUF框架的go语言实现，而Docker Content Trust是TUF框架的应用。理清三者关系有助于后续理解。
1.2 TUF的角色 TUF框架包含五类角色，对应五把密钥，分别是Root, Target, Snapshot, Timestamp, Delegated target(可选)，每个角色对应一个元数据文件及一把密钥。
TUF角色和密钥的理解与Notary介绍有重合，可以参考 &amp;quot;2.3 Notary的密钥管理&amp;quot;
1.2 TUF的工作流 TUF框架的定义在这里：https://github.com/theupdateframework/specification/blob/master/tuf-spec.md 。
step 0: 加载可信的root元数据文件 这一步可以认为是前奏步骤。一个初始的root元数据文件应该早已经随包管理器交付到客户端，或者通过带外流程放置进去了。此时的root元数据文件的超时不重要，因为下一步会更新它。
step 1: 更新root元数据文件 由于现在元数据文件可能是被完全不同的一组key签名的，客户端必须有办法能持续的更新到最新的密钥，通过不断的下载中间阶段的密钥一直到最新版。
step 1.1: 使用N代表可信root元数据文件的版本号 step 1.2: 下载root元数据文件的N+1版本 文件名是固定的格式：VERSION_NUMBER.FILENAME.EXT (e.g., 42.root.json)。不成功的话跳转到1.8步。
step 1.3: 检查签名 N+1版的root元数据必须被以下密钥签名：1）N版本root元数据内指定的达到阈值数量的密钥。2）新版本的root元数据里指定的达到阈值数量的密钥。
如果N+1版本的root元数据没有被正确签名，退出并报错。
step 1.4: 检查回滚攻击(rollback attach) 当前信任的root元数据文件版本（N）必须小于新的root元数据文件（N+1）。如果不是退出并报错。
step 1.5: 新版本元数据文件的超时时间可以忽略，1.8会检查 step 1.6: 设置受信任的root元数据文件为新的元数据文件 step 1.7: 重复step 1.1到1.7直到root元数据为最新 step 1.8: 检查冻结攻击(freeze attach) 检查当前的信任的root元数据文件是否过期，过期的报错退出。
step 1.9: 如果timestamp和/或snapshot密钥已经改变，删掉snapshot和timestamp元数据文件 这个是为了从快进攻击(fast-forward attach)中恢复出来。快进攻击是攻击者可以任意增加元数据的版本号：1）timestamp元数据。2）snapshot元数据。3）targets元数据。
step 2: 下载timestamp元数据文件 下载固定文件名timestamp.
          
          
        
      </description>
    </item>
    
    <item>
      <title>创建kata的K8s集群</title>
      <link>https://weizhang555.github.io/original/create-k8s-cluster-with-kata/</link>
      <pubDate>Sat, 18 Aug 2018 19:10:00 +0800</pubDate>
      
      <guid>https://weizhang555.github.io/original/create-k8s-cluster-with-kata/</guid>
      <description>
        
          
            本文介绍下如何创建kata的k8s集群， kata项目链接：https://github.com/kata-containers kata是什么不介绍了，能看到这篇文章的相信对kata都已经有一定了解了。
本文参考了官方的安装说明： https://github.com/kata-containers/documentation/blob/master/how-to/how-to-use-k8s-with-cri-containerd-and-kata.md 实际上仅仅安装没有什么好讲的，文档里讲的很清楚了。但是在我们恶劣的大网络环境下，就变得有点技巧了。
以下为正文
安装环境 Virtual Machine:
OS: Ubuntu 18.04
CPU: 4
Memory: 8G
在虚拟化环境中，务必保证嵌套虚拟化打开。
虚拟化软件必须要支持 可以在guest OS里面通过以下命令检查：
1$ sudo grep -E &amp;#34;(vmx|svm)&amp;#34; --color=always /proc/cpuinfo 如果没有显示则不支持硬件虚拟化。需要打开相应的虚拟化选项，如果是物理机则需要bios里面启用虚拟化支持。
启动kvm_intel的嵌套虚拟化支持 1# modprobe -r kvm_intel 2# modprobe kvm_intel nested=1 安装kata-containers 参考：
https://github.com/kata-containers/documentation/blob/master/install/ubuntu-installation-guide.md
运行以下命令：
1$ sudo sh -c &amp;#34;echo &amp;#39;deb http://download.opensuse.org/repositories/home:/katacontainers:/release/xUbuntu_$(lsb_release -rs)/ /&amp;#39; &amp;gt; /etc/apt/sources.list.d/kata-containers.list&amp;#34; 2$ curl -sL http://download.opensuse.org/repositories/home:/katacontainers:/release/xUbuntu_$(lsb_release -rs)/Release.key | sudo apt-key add - 3$ sudo -E apt-get update 4$ sudo -E apt-get -y install kata-runtime kata-proxy kata-shim 安装docker 参考：
          
          
        
      </description>
    </item>
    
    <item>
      <title>Kata Containers介绍，附上演讲ppt</title>
      <link>https://weizhang555.github.io/original/kata-containers-introduction/</link>
      <pubDate>Sun, 08 Apr 2018 22:00:00 +0800</pubDate>
      
      <guid>https://weizhang555.github.io/original/kata-containers-introduction/</guid>
      <description>
        
          
            最近在51cto举办的meetup上做了关于Kata Containers的演讲， KataContainers是github上的新项目，前身是Intel的clear container和Hyper的runv， 融合了普通容器的轻快和虚拟机的高隔离高安全性的优点。
详细可以直接参观Kata Containers的github主页： https://github.com/kata-containers/runtime
演讲的链接传送门：http://developer.huawei.com/ict/forum/thread-48823.html
完整的演讲ppt可以在此处下载： Kata介绍与Huawei_iSula安全容器-张伟.ppt
          
          
        
      </description>
    </item>
    
    <item>
      <title>containerd源码阅读(1)--框架篇</title>
      <link>https://weizhang555.github.io/original/containerd-code-analysis/</link>
      <pubDate>Tue, 12 Sep 2017 22:40:46 +0800</pubDate>
      
      <guid>https://weizhang555.github.io/original/containerd-code-analysis/</guid>
      <description>
        
          
            1. 简介 containerd是与docker直接沟通的下属组件，详细是什么不说了。 每个docker daemon启动的时候都会启动一个containerd daemon，启动容器的时候， 每个容器的init进程／exec进程都会对应一个containerd-shim进程， containerd-shim同样是containerd库里面单独的一个二进制程序， containerd-shim会调用runc最终启动容器。 这些基本的知识一笔带过不详细展开。
随着docker改名为moby，docker的大部分功能，比如image管理，容器运行都会下沉到containerd， docker会越来越侧重于编排调度部分--swarm。
简单分析下containerd的代码架构，作为官方containerd文档的一个补充。 本篇以git commit d700a9c35b09239c8c056cd5df73bc19a79db9a9 为标准讲解。
2. grpc containerd的架构极其依赖grpc协议。
1# ls api/services/ 2containers content diff events images namespaces snapshot tasks version api/services目录下存放着containerd提供的不同服务对应的grpc接口。 以比较基础的content服务为例，
1# ls api/services/content/v1/ 2content.pb.go content.proto 下面一共有两个文件，一个content.proto一个是.pb.go, 其中用户只需要定义content.proto文件， 而程序最终使用的content.pb.go则可以由grpc命令自动生成。 containerd在Makefile中提供了生成.pb.go的指令
1// 安装依赖的库 2# cd containerd &amp;amp;&amp;amp; make setup 3# make protos 打开content.proto 来看，里面主要定义了一个service：
113 service Content { 2 14 // Info returns information about a committed object. 3 15 // 4 16 // This call can be used for getting the size of content and checking for 5 17 // existence.
          
          
        
      </description>
    </item>
    
    <item>
      <title>runc源码阅读</title>
      <link>https://weizhang555.github.io/original/runc-code-analysis/</link>
      <pubDate>Tue, 12 Sep 2017 22:40:46 +0800</pubDate>
      
      <guid>https://weizhang555.github.io/original/runc-code-analysis/</guid>
      <description>
        
          
            runc是docker的核心底层依赖，是容器运行的runtime，目前所属的仓库是opencontainers/runc, 是docker将原先的libcontainer模块独立出来，并贡献给oci社区的产物。
一直想写一下runc的源码分析，但是一直没有时间。暂时先把自己阅读runc过程中画得xmind思维脑图放出来吧， 里面的内容是runc的代码流程分析。有时间再回来补齐源码分析。
runc源码分析xmind文件
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
